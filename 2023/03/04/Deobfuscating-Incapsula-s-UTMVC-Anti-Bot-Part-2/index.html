<!DOCTYPE html><html class="appearance-dark" lang="en"><head><meta charset="UTF-8"><title>Deobfuscating Imperva's utmvc Anti-Bot Script - Part 2</title><meta name="description" content="Mastering the art of reverse engineering"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Part 2 - Control Flow FlatteningFlattening Control FlowIn part 1 we successfully revealed all of the strings in the script. In this part, we are going to tackle the control flow obfuscation. Control flow obfuscation is a technique to jumble up the order of code in order to make it harder to follow. It jumps around and is usually found in a switch block. I’.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">yog's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Deobfuscating Imperva's utmvc Anti-Bot Script - Part 2</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part-2-Control-Flow-Flattening"><span class="toc-text">Part 2 - Control Flow Flattening</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flattening-Control-Flow"><span class="toc-text">Flattening Control Flow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Removing-Proxy-References"><span class="toc-text">Removing Proxy References</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Deobfuscating Imperva's utmvc Anti-Bot Script - Part 2</h1><time class="has-text-grey" datetime="2023-03-04T23:08:36.000Z">2023-03-04</time><article class="mt-2 post-content"><h1 id="Part-2-Control-Flow-Flattening"><a href="#Part-2-Control-Flow-Flattening" class="headerlink" title="Part 2 - Control Flow Flattening"></a><strong>Part 2 - Control Flow Flattening</strong></h1><h2 id="Flattening-Control-Flow"><a href="#Flattening-Control-Flow" class="headerlink" title="Flattening Control Flow"></a>Flattening Control Flow</h2><p>In part 1 we successfully revealed all of the strings in the script. In this part, we are going to tackle the control flow obfuscation. Control flow obfuscation is a technique to jumble up the order of code in order to make it harder to follow. It jumps around and is usually found in a <code>switch</code> block. I’ve included a visual representation of what that might look like below.</p>
<p><img src="https://pbs.twimg.com/media/FSEiVswXIAIqe7n.jpg" alt="Virus Bulletin on Twitter: &quot;Sophos&#39; @hackingump1 writes an introduction to control  flow flattening in Emotet. Control flow flattening is an obfuscation  technique that hides program flow by putting all function blocks next"></p>
<p>We can see examples of this in the script we’ve partially deobfuscated so far:</p>
<pre><code class="js">    var _0x3100a2 = &quot;4|2|3|1|6|5|7|0|9|8&quot;[&quot;split&quot;](&quot;|&quot;),
      _0x6753ae = 0x0;
    while (!![]) &#123;
      switch (_0x3100a2[_0x6753ae++]) &#123;
        case &quot;0&quot;:
          _0x4e96ba[&quot;Pgl&quot;](_0x14d4e9, _0x4e96ba[&quot;uLq&quot;](_0x2bcd36, _0x4bc649));
          continue;
        case &quot;1&quot;:
          _0x4bc649[&quot;push&quot;]([&quot;&#39;v8b33affa616d7e2343cc7cd58fb6cd20c99ad6b16413b7c5af014cfde3a957ad&#39;.toString()&quot;, &quot;value&quot;]);
          continue;
        case &quot;2&quot;:
          if (!_0x530384[&quot;btoa&quot;]) _0x530384[&quot;btoa&quot;] = _0x48c673;
          continue;
        case &quot;3&quot;:
          _0x4e96ba[&quot;gGv&quot;](_0x3abf6a);
          continue;
        case &quot;4&quot;:
          if (_0x1e92fd) &#123;
            try &#123;
              _0x2e9a92[&quot;log&quot;] = _0x4e96ba[&quot;uLq&quot;](_0x19195e, _0x1e92fd);
            &#125; catch (_0x3fc75d) &#123;&#125;
          &#125;
          continue;
        case &quot;5&quot;:
          var _0x290d1c = _0x20a23a[&quot;substr&quot;](0x0, 0x2);
          continue;
        case &quot;6&quot;:
          var _0x20a23a = &quot;bO+/vQxkbu+/vXQgXu+/ve+/vUHvv73vv71d77+9&quot;;
          continue;
        case &quot;7&quot;:
          var _0x5a434c = _0x20a23a[&quot;substr&quot;](0x2);
          continue;
        case &quot;8&quot;:
          _0x4fd281[&quot;createElement&quot;](&quot;img&quot;)[&quot;src&quot;] = _0x4e96ba[&quot;LZO&quot;](&quot;/_Incapsula_Resource?SWKMTFSR=1&amp;e=&quot;, _0x530384[&quot;Math&quot;][&quot;random&quot;]());
          continue;
        case &quot;9&quot;:
          if (_0x163515) &#123;
            _0x4bc649[&quot;push&quot;]([_0x163515, &quot;value&quot;]);
            _0x4e96ba[&quot;uLq&quot;](_0x14d4e9, _0x4e96ba[&quot;FRS&quot;](_0x2bcd36, _0x4bc649));
          &#125;
          continue;
      &#125;
      break;
    &#125;
</code></pre>
<p>We can see that <code>_0x3100a2</code> is a variable which contains string literals, that is <code>split</code> by <code>|</code>. The <code>swtich</code> statement then loops through each element and runs the code under each switch statement. The end goal here is to simplify the code to something like this:</p>
<pre><code class="js">//Code from switch &quot;4&quot;
if (_0x1e92fd) &#123;
try &#123;
  _0x2e9a92[&quot;log&quot;] = _0x4e96ba[&quot;uLq&quot;](_0x19195e, _0x1e92fd);
&#125; catch (_0x3fc75d) &#123;&#125;
&#125;

//Code from switch &quot;2&quot;
if (!_0x530384[&quot;btoa&quot;]) _0x530384[&quot;btoa&quot;] = _0x48c673;

//Code from switch &quot;3&quot;
_0x4e96ba[&quot;gGv&quot;](_0x3abf6a);

//Code from switch &quot;1&quot;
_0x4bc649[&quot;push&quot;]([&quot;&#39;v8b33affa616d7e2343cc7cd58fb6cd20c99ad6b16413b7c5af014cfde3a957ad&#39;.toString()&quot;, &quot;value&quot;]);
... etc
</code></pre>
<p>And here is our resulting Babel plugin:</p>
<pre><code class="js">const t = require(&quot;@babel/types&quot;);
const parser = require(&quot;@babel/parser&quot;);
const traverse = require(&quot;@babel/traverse&quot;).default;

const flattenControlFlowVisitor = &#123;
    SwitchStatement(path)&#123;
        const &#123; node &#125; = path;
        if(t.isMemberExpression(node.discriminant) &amp;&amp;
            t.isIdentifier(node.discriminant.object) &amp;&amp;
            t.isUpdateExpression(node.discriminant.property) &amp;&amp;
            node.discriminant.property.operator === &quot;++&quot; &amp;&amp;
            node.discriminant.property.prefix === false)
        &#123;
            //We&#39;re in the right switch statement

            //Get the switch order variable name
            //e.g.     var _0x48d663 = &quot;3|6|2|0|5|1|4&quot;[&quot;split&quot;](&quot;|&quot;), ---&gt; _0x48d663
            const switchOrderVar = node.discriminant.object.name;

            //Get the bindings of the variable and get the switch order into an array
            const switchOrder = path.scope.getBinding(switchOrderVar).path.node.init.callee.object.value.split(&quot;|&quot;)

            let orderedNodes = []

            //Loop through the switch order
            for(const sw of switchOrder)&#123;
                //Get the switch cases that belong to the switch
                const switchCase = path.node.cases.find(c =&gt; c.test.value === sw);
                
                //Get the nodes under the switch excluding the continue statement
                const nodesInSwitchCase = switchCase.consequent.filter(c =&gt; !t.isContinueStatement(c))
                
                //Drop them into an array
                //cloneDeepWithoutLoc to avoid issues!
                orderedNodes.push(...nodesInSwitchCase.map(n =&gt; t.cloneDeepWithoutLoc(n)))
            &#125;
            
            //Replace the parent while statement
            const whileStatement = path.parentPath.parentPath;
            whileStatement.replaceWithMultiple(orderedNodes);
        &#125;
    &#125;
&#125;

traverse(ast, flattenControlFlowVisitor);
traverse(ast, flattenControlFlowVisitor); //Run it twice!
</code></pre>
<p>You’ll notice that we need to run this visitor twice, this is because there are nested switch statements. One improvement that could be made to this visitor is to make it recursive. This would make it more efficient and mean that we don’t have to traverse the AST twice. We’ve now simplified the ugly control flow code into this:</p>
<pre><code class="js">function _0x4d748b(_0x1b013d) &#123;
var _0x3a900f = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
var _0x2026be, _0x30a9be, _0x105a8e;
var _0x337f59, _0x32ce20, _0x52c47a;
_0x105a8e = _0x1b013d[&quot;length&quot;];
_0x30a9be = 0x0;
_0x2026be = &quot;&quot;;
while (_0x388c13[&quot;wag&quot;](_0x30a9be, _0x105a8e)) &#123;
  var _0x4a9695 = &quot;6|8|7|2|0|1|4|3|5&quot;[&quot;split&quot;](&quot;|&quot;),
    _0x1a9326 = 0x0;
  _0x337f59 = _0x388c13[&quot;YnZ&quot;](_0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++), 0xff);
  if (_0x388c13[&quot;PNJ&quot;](_0x30a9be, _0x105a8e)) &#123;
    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x337f59 &gt;&gt; 0x2);
    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;fza&quot;](_0x388c13[&quot;yuG&quot;](_0x337f59, 0x3), 0x4));
    _0x2026be += &quot;==&quot;;
    break;
  &#125;
  _0x32ce20 = _0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++);
  if (_0x388c13[&quot;PNJ&quot;](_0x30a9be, _0x105a8e)) &#123;
    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;ydV&quot;](_0x337f59, 0x2));
    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;AfV&quot;](_0x388c13[&quot;XCm&quot;](_0x337f59, 0x3) &lt;&lt; 0x4, (_0x32ce20 &amp; 0xf0) &gt;&gt; 0x4));
    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;pYD&quot;](_0x32ce20, 0xf) &lt;&lt; 0x2);
    _0x2026be += &quot;=&quot;;
    break;
  &#125;
  _0x52c47a = _0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++);
  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;Oed&quot;](_0x337f59, 0x2));
  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;VuS&quot;](_0x388c13[&quot;jpt&quot;](_0x337f59, 0x3) &lt;&lt; 0x4, _0x388c13[&quot;ydV&quot;](_0x388c13[&quot;EML&quot;](_0x32ce20, 0xf0), 0x4)));
  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;sWH&quot;](_0x32ce20 &amp; 0xf, 0x2) | _0x388c13[&quot;ydV&quot;](_0x388c13[&quot;uQC&quot;](_0x52c47a, 0xc0), 0x6));
  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;EML&quot;](_0x52c47a, 0x3f));
&#125;
return _0x2026be;
&#125;
</code></pre>
<h2 id="Removing-Proxy-References"><a href="#Removing-Proxy-References" class="headerlink" title="Removing Proxy References"></a>Removing Proxy References</h2><p>The next obfuscation technique we’re going to tackle is proxy references. Proxy references are calls to functions that execute another function. The end goal here is to replace any calls to proxy functions with their intended function calls.</p>
<p>We can see examples of proxy calls in the code, e.g:</p>
<pre><code class="js">&quot;Pjt&quot;: function _0x1068f3(_0x1dcc0d, _0x4fccf2) &#123;
  return _0x1dcc0d + _0x4fccf2;
&#125;,
</code></pre>
<p>Here we have a function that is defined as <code>Pjt</code>, and all this is doing is doing a simple addition on the two parameters.</p>
<p>First thing we need to do is traverse through the script and identify any objects that define the proxy functions. You’ll see that the proxy references are contained in an object like so:</p>
<pre><code class="js">var _0x388c13 = &#123;
&quot;wag&quot;: function _0x67d457(_0x2f20be, _0x4a591a) &#123;
  return _0x2f20be &lt; _0x4a591a;
&#125;,
</code></pre>
<p>The goal is to build a lookup table of the object variable name (<code>_0x388c13</code>) and all the proxy functions it contains. We can achieve this with this visitor:</p>
<pre><code class="js">this.proxyFuncVars = &#123;&#125;
path.traverse(&#123;
    ObjectProperty(path)&#123;
        const &#123; node &#125; = path;
        if (t.isFunctionExpression(node.value) &amp;&amp; t.isReturnStatement(node.value.body.body[0]))&#123;
            //Found a proxy expression
            const varDecl = path.getStatementParent()
            if (!this.proxyFuncVars[varDecl.node.declarations[0].id.name]) &#123;
                this.proxyFuncVars[varDecl.node.declarations[0].id.name] = [];
            &#125;

            this.proxyFuncVars[varDecl.node.declarations[0].id.name].push([node.key.value, node.value]);
        &#125;
    &#125;
&#125;)
</code></pre>
<p>We now have a lookup table that looks like this:</p>
<p><img src="/images/2.png" alt="image-20230306151919010"></p>
<p>The next thing that we need to do is traverse <code>CallExpressions</code> and see if it belongs in our lookup table. If it does, we can simply replace the <code>CallExpression</code> with the proxy function. Here is a visitor that does just that:</p>
<pre><code class="js">function findProxyFunction(lookupTable, varName, funcName)&#123;
    for(const key of Object.keys(lookupTable))&#123;
        if (key === varName)&#123;
            for(const func of lookupTable[key])&#123;
                if (func[0] === funcName)&#123;
                    return func[1]
                &#125;
            &#125;
        &#125;
    &#125;
    return null
&#125;

CallExpression(path)&#123;
    const &#123; node &#125; = path;
    if (
        t.isMemberExpression(node.callee) &amp;&amp;
        t.isIdentifier(node.callee.object) &amp;&amp;
        findProxyFunction(this.proxyFuncVars, node.callee.object.name, node.callee.property.name)
    )&#123;
        const varName = node.callee.object.name;
        const funcName =  node.callee.property.name;

        const proxyFunc = findProxyFunction(this.proxyFuncVars, varName, funcName);
        if (proxyFunc)&#123;
            //We found a proxy function, so do a replacement
            if (t.isBinaryExpression(proxyFunc.body.body[0].argument))&#123;
                const funcBinaryExpression = proxyFunc.body.body[0].argument;
                path.replaceWith(t.binaryExpression(funcBinaryExpression.operator, node.arguments[0], node.arguments[1]))
            &#125; else if (t.isCallExpression(proxyFunc.body.body[0].argument))&#123;
                const funcName = node.arguments.slice(1);
                path.replaceWith(t.callExpression(node.arguments[0], funcName))
            &#125;
        &#125;
    &#125;
&#125;,
</code></pre>
<blockquote>
<p><strong>Caution:</strong> The above code doesn’t consider the ordering of the arguments. For the utmvc script it’s not a problem since they’re always in order, however you should consider the argument positioning for other obfuscated code</p>
</blockquote>
<p>We’ve now transformed the code and removed all the proxy references!</p>
<p>Before:</p>
<pre><code class="js">_0x25c494[_0x25c494.length] = _0x5cf4da.bfY(_0x4ce1f7, _0x5cf4da.szJ(_0x412285, &quot;=undefined&quot;));
</code></pre>
<p>After:</p>
<pre><code class="js">_0x25c494[_0x25c494.length] = _0x4ce1f7(_0x412285 + &quot;=undefined&quot;);
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot/" title="Deobfuscating Imperva's utmvc Anti-Bot Script - Part 1"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Deobfuscating Imperva's utmvc Anti-Bot Script - Part 1</span></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/yoghurtbot"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/yoghurtbot"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> yog 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>