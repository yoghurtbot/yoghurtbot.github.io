<!DOCTYPE html><html class="appearance-dark" lang="en"><head><meta charset="UTF-8"><title>Android Reversing - Finding the RSA Key of Akamai BMP</title><meta name="description" content="Mastering the art of reverse engineering"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="IntroductionThis article I am going to show you how you can use various tools to reverse engineer Android applications. The goal of this article will be to reverse engineer an Android application that uses Akamai’s Bot Manager Premier (BMP), aka the mobile protection SDK. You can recognise this from the x-acf-sensor-data header that is sent with requests.
.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">yog's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Android Reversing - Finding the RSA Key of Akamai BMP</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Android-OS-and-Dalvik-Bytecode"><span class="toc-text">The Android OS and Dalvik Bytecode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-Started"><span class="toc-text">Getting Started</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Decompiling-the-APK"><span class="toc-text">Decompiling the APK</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Native-Library-Analysis"><span class="toc-text">Native Library Analysis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hooking-Native-Functions-using-Frida"><span class="toc-text">Hooking Native Functions using Frida</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Going-One-Step-Further"><span class="toc-text">Going One Step Further</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Android Reversing - Finding the RSA Key of Akamai BMP</h1><time class="has-text-grey" datetime="2023-03-04T23:08:36.000Z">2023-03-04</time><article class="mt-2 post-content"><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>This article I am going to show you how you can use various tools to reverse engineer Android applications. The goal of this article will be to reverse engineer an Android application that uses Akamai’s Bot Manager Premier (BMP), aka the mobile protection SDK. You can recognise this from the <code>x-acf-sensor-data</code> header that is sent with requests.</p>
<h2 id="The-Android-OS-and-Dalvik-Bytecode"><a href="#The-Android-OS-and-Dalvik-Bytecode" class="headerlink" title="The Android OS and Dalvik Bytecode"></a>The Android OS and Dalvik Bytecode</h2><p>Android is built on a modified version of the Linux kernel and is open-source. One of the key components of the Android OS is the Dalvik virtual machine, which is responsible for running applications written in Java or Kotlin. When an Android application is compiled, the Java code is converted into Dalvik bytecode, which is a set of low-level instructions (think of it like assembly for Windows), that can be executed by the Dalvik virtual machine. The Dalvik bytecode is optimised for use on mobile devices with limited processing power and memory, which ultimately allows apps to run efficiently on a wide range of devices.</p>
<p>Since Android is based on Linux, it can also make use of compiled shared library binaries (<code>.so</code> format). The Dynamic Linker is responsible for loading and accessing resources compiled in a shared library. Since version 3.3.0, Akamai BMP uses shared libraries to offload some routines to native libraries with the intent to make it harder to reverse engineer. It will also give a slight speed improvement since the code is running natively.</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>We’re going to need the following tools for this exercise:</p>
<ul>
<li>jadx - <a target="_blank" rel="noopener" href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a></li>
<li>Ghidra - <a target="_blank" rel="noopener" href="https://github.com/NationalSecurityAgency/ghidra/release">https://github.com/NationalSecurityAgency/ghidra/release</a></li>
<li>apktool - <a target="_blank" rel="noopener" href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a></li>
<li>Frida - <a target="_blank" rel="noopener" href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li>
<li>An APK that has Akamai BMP (for this I’ll be using the <a target="_blank" rel="noopener" href="https://play.google.com/store/apps/details?id=de.apptiv.business.android.aldi_uk&hl=en_GB&gl=US">Aldi APK</a>)</li>
</ul>
<p>The first thing we want to do is ensure that our target actually has Akamai BMP installed. The easiest way to do this is to open the APK in jadx, and search for the <code>x-acf-sensor-data</code> string:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/3.png" alt="image-20230309180017125"></h2><p>Great, this is a valid target. The next thing we need to do is decompile the APK. The structure of an APK is organized into several directories and files. The root directory contains files such as the manifest file, which provides information about the app’s components, permissions, and metadata. The assets directory contains static files such as images and sound files. The <code>lib</code> directory contains compiled libraries that are specific to a particular CPU architecture. The res directory contains resources such as strings, layouts, and drawables that are used by the app’s user interface. The classes.dex file contains the app’s compiled code in the form of Dalvik bytecode.</p>
<h1 id="Decompiling-the-APK"><a href="#Decompiling-the-APK" class="headerlink" title="Decompiling the APK"></a>Decompiling the APK</h1><p>To decompile the APK we will use <code>apktool</code> :  <code>java -jar apktool_2.5.0.jar d &quot;ALDI UK_7.9.0.124_Apkpure.apk&quot;</code></p>
<p>After we’ve ran <code>apktool</code> we will have a folder with all the decompiled parts of the APK</p>
<p><img src="/images/4.png" alt="image-20230321234428989"></p>
<p>If we take a look in the <code>lib</code> folder we can find the compiled <code>.so</code> binaries for Akamai; <code>lib\x86_64\libakamaibmp.so</code></p>
<h1 id="Native-Library-Analysis"><a href="#Native-Library-Analysis" class="headerlink" title="Native Library Analysis"></a>Native Library Analysis</h1><p>We are next going to analyze the <code>.so</code> native library file. <code>.so</code> is the equivalent of a Dynamic Link Library (<code>.dll</code>) on Windows. To analyze this file we will use Ghidra. This is also often referred to as a shared library. Open up Ghidra and drag in the file so we can start the analysis process.</p>
<p><img src="/images/5.png" alt="image-20230322000553178"></p>
<p>If we go back to JADX and have a look at this code, we can see the references to some functions inside the shared object file.</p>
<pre><code class="java">package com.cyberfend.cyfsecurity;

import android.util.Pair;
import java.util.ArrayList;

/* loaded from: classes.dex */
public final class SensorDataBuilder &#123;

    /* renamed from: a */
    private static final SensorDataBuilder f387a = new SensorDataBuilder();

    public final native synchronized String buildN(ArrayList&lt;Pair&lt;String, String&gt;&gt; arrayList);

    public final native synchronized void initializeKeyN();

    SensorDataBuilder() &#123;
    &#125;

    static &#123;
        System.loadLibrary(&quot;akamaibmp&quot;);
    &#125;

    /* renamed from: a */
    public static SensorDataBuilder m5136a() &#123;
        return f387a;
    &#125;

    /* renamed from: com.cyberfend.cyfsecurity.SensorDataBuilder$1 */
    /* loaded from: classes.dex */
    final class AnonymousClass1 implements Runnable &#123;
        /* JADX INFO: Access modifiers changed from: package-private */
        public AnonymousClass1() &#123;
        &#125;

        @Override // java.lang.Runnable
        public final void run() &#123;
            SensorDataBuilder.this.initializeKeyN();
        &#125;
    &#125;
&#125;
</code></pre>
<p>We can see that native functions are called: <code>buildN</code> and <code>initializeKeyN</code>. This must mean that the shared library exports these functions to make them available in Java. If we go back to Ghidra, we can search for these functions in the symbol tree:</p>
<p><img src="/images/6.png" alt="image-20230322001140993"></p>
<p>Double clicking on the pink text under exports will decompile the function into pseudo-c</p>
<pre><code class="c">void Java_com_cyberfend_cyfsecurity_SensorDataBuilder_initializeKeyN(void)

&#123;
  int iVar1;
  uchar **ppuVar2;
  uchar *puVar3;
  long in_FS_OFFSET;
  uchar *puStack88;
  uchar *apuStack80 [2];
  void *pvStack64;
  Crypto CStack56;
  uchar auStack55 [15];
  uchar *puStack40;
  long lStack32;
  
  ppuVar2 = (uchar **)SensorDataBuilder::getInstance();
  lStack32 = *(long *)(in_FS_OFFSET + 0x28);
  if (*(char *)(ppuVar2 + 5) == &#39;\0&#39;) &#123;
    puVar3 = (uchar *)operator.new[](0x11);
    *ppuVar2 = puVar3;
    Crypto::randomBytes(0x10,ppuVar2);
    std::__ndk1::basic_string&lt;char,std::__ndk1::char_traits&lt;char&gt;,std::__ndk1::allocator&lt;char&gt;&gt;::
    basic_string&lt;decltype(nullptr)&gt;
              ((basic_string&lt;char,std::__ndk1::char_traits&lt;char&gt;,std::__ndk1::allocator&lt;char&gt;&gt; *)
               apuStack80,
               &quot;-j0ZOfGt%xoJ$.p%U&lt;#~.Bnx#M\nk?-%PwI&amp;Yg+&gt;#|;0W1F&#123;?0@WVJE+#8d 6]Jy2V2_&lt;uqM:HbEfN8j/fy, L^(Prg&#125;yLPi^Xp&amp;ot43flfpXu`h AmT).TJ;*fdo^f;G@J84LcY!U-QKo[:]Be5)h&gt;v6HN*rjS,^|*&lt;K+(6|| yxRxH:S#4&gt;FSYVwK=z&lt;_SH&amp;*L+qWor+.fNpo_Q@o_8@t&#123;KAqQxc#Z(%X,r^[q)~*;+b8Plb&lt;Mrc\n8(&amp;U++!| Z8HPGT5oa/BqAbX6&quot;
              );
    Crypto::rotate_string(&amp;CStack56,(basic_string *)apuStack80,0x3f,-1);
    if (((ulong)apuStack80[0] &amp; 1) != 0) &#123;
      operator.delete(pvStack64);
    &#125;
....
</code></pre>
<p>The first thing that immediately jumps out is the reference to another function: <code>rotate_string</code> which takes 3 parameters. <code>&amp;CStack56</code> is likely a pointer to to an instance of the <code>Crypto</code> class, <code>0x3f</code> is the rotation value (in this case <code>63</code>) and the third parameter <code>-1</code> could indicate the rotation direction.</p>
<p>If we double click the <code>rotate_string</code> function, we again get pseudo-c code for the function. We could try and reverse engineer this code, but it’s quite complicated with a lot of bit-shifting type code and memory allocation. Instead we can find another attack vector that will make our lives a lot easier, which I’ll explain below.</p>
<pre><code class="c">Crypto::rotate_string(Crypto *this,basic_string *param_1,uint param_2,int param_3)

&#123;
  char cVar1;
  undefined *puVar2;
  ulong uVar3;
  ulong uVar4;
  int iVar5;
  ulong uVar6;
  basic_string *pbVar7;
  basic_string bVar8;
  long lVar9;
  ulong uVar10;
  long in_FS_OFFSET;
  bool bVar11;
  undefined local_178 [4];
  undefined4 uStack372;
  undefined8 uStack368;
  undefined *local_168;
  undefined local_158 [8];
  ulong uStack336;
  undefined *local_148;
  undefined local_138 [16];
  undefined local_128 [16];
  undefined local_118 [16];
...
  local_48 = local_138;
  do &#123;
    cVar1 = (char)lVar9;
    if ((0x3a &lt; (byte)(cVar1 - 0x22U)) ||
       ((0x400000000000021U &gt;&gt; ((ulong)(byte)(cVar1 - 0x22U) &amp; 0x3f) &amp; 1) == 0)) &#123;
      if (cVar1 == &#39;\x7f&#39;) break;
      bVar11 = (_local_158 &amp; (undefined  [16])0x1) != (undefined  [16])0x0;
      if (bVar11) &#123;
        uVar3 = (local_158 &amp; 0xfffffffffffffffe) - 1;
      &#125;
      else &#123;
        uStack336 = (ulong)((byte)local_158[0] &gt;&gt; 1);
        uVar3 = 0x16;
      &#125;
      local_138[lVar9] = (char)uStack336;
      if (uStack336 == uVar3) &#123;
                    /* try &#123; // try from 001a868f to 001a86ac has its CatchHandler @ 001a8955 */
...
</code></pre>
<p>So it looks as if this function is designed to decode&#x2F;decrypt a string, and there is some interesting text that we need to decode.</p>
<p>Again looking at the pseudo-c code of <code>initializeKeyN</code> we can see that the decoded string is later passed as a pointer parameter in a function called <code>RSAEncrypt</code> (look at <code>apuStack80</code>).</p>
<pre><code class="c">    basic_string&lt;decltype(nullptr)&gt;
              ((basic_string&lt;char,std::__ndk1::char_traits&lt;char&gt;,std::__ndk1::allocator&lt;char&gt;&gt; *)
               apuStack80,
               &quot;-j0ZOfGt%xoJ$.p%U&lt;#~.Bnx#M\nk?-%PwI&amp;Yg+&gt;#|;0W1F&#123;?0@WVJE+#8d 6]Jy2V2_&lt;uqM:HbEfN8j/fy, L^(Prg&#125;yLPi^Xp&amp;ot43flfpXu`h AmT).TJ;*fdo^f;G@J84LcY!U-QKo[:]Be5)h&gt;v6HN*rjS,^|*&lt;K+(6|| yxRxH:S#4&gt;FSYVwK=z&lt;_SH&amp;*L+qWor+.fNpo_Q@o_8@t&#123;KAqQxc#Z(%X,r^[q)~*;+b8Plb&lt;Mrc\n8(&amp;U++!| Z8HPGT5oa/BqAbX6&quot;
              );
    Crypto::rotate_string(&amp;CStack56,(basic_string *)apuStack80,0x3f,-1);
    if (((ulong)apuStack80[0] &amp; 1) != 0) &#123;
      operator.delete(pvStack64);
    &#125;
    apuStack80[0] = (uchar *)operator.new[](0x81);
    puVar3 = auStack55;
    if (((byte)CStack56 &amp; 1) != 0) &#123;
      puVar3 = puStack40;
    &#125;
    iVar1 = Crypto::RSAEncrypt(puVar3,0x10,*ppuVar2,apuStack80);
</code></pre>
<p>If we double click the <code>RSAEncrypt</code> function, we can see that it is a function that accepts 4 parameters: a pointer, int, pointer and pointer to a pointer. This will be our alternative attack vector.</p>
<p><code>int Crypto::RSAEncrypt(uchar *param_1,int param_2,uchar *param_3,uchar **param_4)</code></p>
<p>The parameter we’re interested in is the <code>param_1</code>, as this is going to be the decrypted string value that is decoded by the <code>rotate_string</code> function.</p>
<h1 id="Hooking-Native-Functions-using-Frida"><a href="#Hooking-Native-Functions-using-Frida" class="headerlink" title="Hooking Native Functions using Frida"></a>Hooking Native Functions using Frida</h1><p>Okay so we know that we want to somehow read the value of the <code>param_1</code> pointer. We can us Frida to do just that. I am going to assume that you have already setup a rooted Android device and installed Frida on your device. We’re now going to write a Frida hook in JS that will hook into the native function of <code>RSAEncryprt</code>, intercept the parameters and dump it to the console.</p>
<p>We first create our basic <code>hook.js</code> file:</p>
<pre><code class="js">console.log(&quot;Started&quot;);

function waitForLibLoading(libraryName) &#123;
    var isLibLoaded = false;

    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;
        onEnter: function (args) &#123;
            var libraryPath = Memory.readCString(args[0]);
            if (libraryPath.includes(libraryName)) &#123;
                console.log(&quot;[+] Loading library &quot; + libraryPath + &quot;...&quot;);
                isLibLoaded = true;
            &#125;
        &#125;,
        onLeave: function (args) &#123;
            if (isLibLoaded) &#123;                
                isLibLoaded = false;
            &#125;
        &#125;
    &#125;);
&#125;

waitForLibLoading(&quot;libakamaibmp.so&quot;);
</code></pre>
<p>This code will hook the <code>android_dlopen_ext</code> API call, which is the Dynamic Linker on Android. The Dynamic Linker on Android is responsible for resolving dependencies between shared libraries at runtime. When an application loads a shared library with <code>android_dlopen_ext</code>, the Dynamic Linker checks the library’s dependencies and recursively loads any additional libraries required by the application. The linker then resolves symbol references between the libraries, allowing the application to use functions and data defined in the shared libraries.</p>
<p>So we’ve now hooked the Dynamic Linker and have found where <code>libakamaibmp</code> has been loaded. The next step is we need to find the memory address of the library and also the memory address of the <code>RSAEncrypt</code> function, so we can read the memory locations.</p>
<p>If we search for <code>RSAEncrypt</code> in the Symbol Tree, we can see it’s virtual memory address in Ghidra. In our case the address is <code>0x001a4258</code>. This address isn’t quite correct just yet. </p>
<p><img src="/images/10.png" alt="image-20230322112310046"></p>
<p>We now need to find the Base Image Address. When a program is loaded into memory, the operating system assigns it a base image address where it’s code and data will be located, and is fixed  (for the most part) for the duration of programs execution. The Base Image Address is used as an offset for all memory references made by the program. For example, if a program tries to access a memory location at offset <code>0x1000</code> and it’s Base Image Address is <code>0x80000000</code>, the actual physical memory location address being access will be <code>0x80001000</code>.</p>
<p>To get the Base Image Address of this particular shared library, you can grab it from Ghidra by clicking Window -&gt; Memory Map. In this case, the Base Image Address is <code>0x001000000</code></p>
<p><img src="/images/9.png" alt="image-20230322110858847"></p>
<p>We can now write the following Frida code to find the correct memory location of <code>RSAEncrypt</code></p>
<pre><code class="js">function process(libraryName)&#123;
    const rsaEncryptAddress = 0x001a4258
    const imageBase = 0x00100000
    const memBase = Module.findBaseAddress(libraryName);
    console.log(&quot;-&gt; Base address is &quot; + memBase);

    //Find the actual address by subtracting the image base
    const actualRsaEncryptAddress = memBase.add(rsaEncryptAddress - imageBase);
    console.log(&quot;[+] RSAEncrypt Physical Address &quot; + actualRsaEncryptAddress);
&#125;
</code></pre>
<p>We now have the physical address of <code>RSAEncrypt</code> as it’s loaded in memory. Next we need to write a hook to intercept the function and it’s parameters. Remember I mentioned earlier that the first parameter of <code>RSAEncrypt</code> is the plain-text RSA key, so we can hook that parameter and read it as a UTF-8 string.</p>
<pre><code class="js">Interceptor.attach(actualRsaEncryptAddress, &#123;
    onEnter: function(args) &#123;
        console.log(&quot;Hooked RSAEncrypt&quot;);
        const rsaPublicKey = Memory.readUtf8String(args[0]); //public key is the first arg, and is type uchar *
        console.log(rsaPublicKey);
    &#125;,
    onLeave: function(retval) &#123;
        console.log(&quot;Leaving RSAEncrypt&quot;);
    &#125;
&#125;);
    
</code></pre>
<p>If we now put all this together and run the code in Frida, we can see the results!</p>
<p><code>frida -l hook.js -U -f de.apptiv.business.android.aldi_uk</code></p>
<p><img src="/images/8.png" alt="image-20230322112515124"></p>
<p>And here’s our final code:</p>
<pre><code class="js">console.log(&quot;Started&quot;);

function process(libraryName)&#123;
    const rsaEncryptAddress = 0x001a4258
    const imageBase = 0x00100000
    const memBase = Module.findBaseAddress(libraryName);
    console.log(&quot;-&gt; Base address is &quot; + memBase);

    //Find the actual address by subtracting the image base
    const actualRsaEncryptAddress = memBase.add(rsaEncryptAddress - imageBase);
    console.log(&quot;[+] Actual RSA Encrypt Address &quot; + actualRsaEncryptAddress);
    
    Interceptor.attach(actualRsaEncryptAddress, &#123;
        onEnter: function(args) &#123;
            console.log(&quot;Hooked RSAEncrypt&quot;);
            const rsaPublicKey = Memory.readUtf8String(args[0]); //public key is the first arg, and is type uchar *
            console.log(rsaPublicKey);
        &#125;,
        onLeave: function(retval) &#123;
            console.log(&quot;Leaving RSAEncrypt&quot;);
        &#125;
    &#125;);
&#125;

function waitForLibLoading(libraryName) &#123;
    var isLibLoaded = false;

    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;
        onEnter: function (args) &#123;
            var libraryPath = Memory.readCString(args[0]);
            if (libraryPath.includes(libraryName)) &#123;
                console.log(&quot;[+] Loading library &quot; + libraryPath + &quot;...&quot;);
                isLibLoaded = true;
            &#125;
        &#125;,
        onLeave: function (args) &#123;
            if (isLibLoaded) &#123;            
                process(libraryName);			
                isLibLoaded = false;
            &#125;
        &#125;
    &#125;);
&#125;

waitForLibLoading(&quot;libakamaibmp.so&quot;);
</code></pre>
<h2 id="Going-One-Step-Further"><a href="#Going-One-Step-Further" class="headerlink" title="Going One Step Further"></a>Going One Step Further</h2><p>Akamai BMP uses AES to encrypt sensors, which is also handled in the shared library. Further digging around in Ghidra we find another function of interest: <code>AESEncrypt</code></p>
<p><img src="/images/12.png" alt="image-20230322113338426"></p>
<p>We can take the information we’ve learnt from this article to apply the same theory to this function:</p>
<ol>
<li>Find the virtual address of the function</li>
<li>Translate it to a physical address</li>
<li>Build a hook</li>
<li>Profit!</li>
</ol>
<pre><code class="js">//AESEncrypt Hook (encrypts the sensor)
const aesEncryptAddr = 0x001a3ff4; //Address of the AESEncrypt method, as found in Ghidra
const aesEncryptBase = Module.findBaseAddress(libraryName);
console.log(&quot;[+] AESEncrypt Base address is &quot; + aesEncryptBase);
const actualAesEncryptAddress = membase.add(aesEncryptAddr - ghidraImageBase);
console.log(&quot;[+] Actual AESEncrypt Address &quot; + actualAesEncryptAddress);

Interceptor.attach(actualAesEncryptAddress, &#123;
    onEnter: function(args) &#123;
        console.log(&quot;Hooked AESEncrypt&quot;);
        const plainSensor = Memory.readUtf8String(args[0]); //sensor is the first arg, and is type uchar *
        console.log(plainSensor);
    &#125;,
    onLeave: function(retval) &#123;
        console.log(&quot;Leaving AESEncrypt&quot;);
    &#125;
&#125;);
</code></pre>
<p>And we can see the results in our console!</p>
<p><img src="/images/11.png" alt="image-20230322113605443"></p>
<p>Until next time!</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot/" title="Deobfuscating Imperva's utmvc Anti-Bot Script - Part 1"><span class="has-text-weight-semibold">Next: Deobfuscating Imperva's utmvc Anti-Bot Script - Part 1</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/yoghurtbot"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/yoghurtbot"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> yog 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>