<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deobfuscating Imperva&#39;s utmvc Anti-Bot Script - Part 2</title>
      <link href="/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot-Part-2/"/>
      <url>/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot-Part-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Part-2-Control-Flow-Flattening"><a href="#Part-2-Control-Flow-Flattening" class="headerlink" title="Part 2 - Control Flow Flattening"></a><strong>Part 2 - Control Flow Flattening</strong></h1><h2 id="Flattening-Control-Flow"><a href="#Flattening-Control-Flow" class="headerlink" title="Flattening Control Flow"></a>Flattening Control Flow</h2><p>In part 1 we successfully revealed all of the strings in the script. In this part, we are going to tackle the control flow obfuscation. Control flow obfuscation is a technique to jumble up the order of code in order to make it harder to follow. It jumps around and is usually found in a <code>switch</code> block. I’ve included a visual representation of what that might look like below.</p><p><img src="https://pbs.twimg.com/media/FSEiVswXIAIqe7n.jpg" alt="Virus Bulletin on Twitter: &quot;Sophos&#39; @hackingump1 writes an introduction to control  flow flattening in Emotet. Control flow flattening is an obfuscation  technique that hides program flow by putting all function blocks next"></p><p>We can see examples of this in the script we’ve partially deobfuscated so far:</p><pre><code class="js">    var _0x3100a2 = &quot;4|2|3|1|6|5|7|0|9|8&quot;[&quot;split&quot;](&quot;|&quot;),      _0x6753ae = 0x0;    while (!![]) &#123;      switch (_0x3100a2[_0x6753ae++]) &#123;        case &quot;0&quot;:          _0x4e96ba[&quot;Pgl&quot;](_0x14d4e9, _0x4e96ba[&quot;uLq&quot;](_0x2bcd36, _0x4bc649));          continue;        case &quot;1&quot;:          _0x4bc649[&quot;push&quot;]([&quot;&#39;v8b33affa616d7e2343cc7cd58fb6cd20c99ad6b16413b7c5af014cfde3a957ad&#39;.toString()&quot;, &quot;value&quot;]);          continue;        case &quot;2&quot;:          if (!_0x530384[&quot;btoa&quot;]) _0x530384[&quot;btoa&quot;] = _0x48c673;          continue;        case &quot;3&quot;:          _0x4e96ba[&quot;gGv&quot;](_0x3abf6a);          continue;        case &quot;4&quot;:          if (_0x1e92fd) &#123;            try &#123;              _0x2e9a92[&quot;log&quot;] = _0x4e96ba[&quot;uLq&quot;](_0x19195e, _0x1e92fd);            &#125; catch (_0x3fc75d) &#123;&#125;          &#125;          continue;        case &quot;5&quot;:          var _0x290d1c = _0x20a23a[&quot;substr&quot;](0x0, 0x2);          continue;        case &quot;6&quot;:          var _0x20a23a = &quot;bO+/vQxkbu+/vXQgXu+/ve+/vUHvv73vv71d77+9&quot;;          continue;        case &quot;7&quot;:          var _0x5a434c = _0x20a23a[&quot;substr&quot;](0x2);          continue;        case &quot;8&quot;:          _0x4fd281[&quot;createElement&quot;](&quot;img&quot;)[&quot;src&quot;] = _0x4e96ba[&quot;LZO&quot;](&quot;/_Incapsula_Resource?SWKMTFSR=1&amp;e=&quot;, _0x530384[&quot;Math&quot;][&quot;random&quot;]());          continue;        case &quot;9&quot;:          if (_0x163515) &#123;            _0x4bc649[&quot;push&quot;]([_0x163515, &quot;value&quot;]);            _0x4e96ba[&quot;uLq&quot;](_0x14d4e9, _0x4e96ba[&quot;FRS&quot;](_0x2bcd36, _0x4bc649));          &#125;          continue;      &#125;      break;    &#125;</code></pre><p>We can see that <code>_0x3100a2</code> is a variable which contains string literals, that is <code>split</code> by <code>|</code>. The <code>swtich</code> statement then loops through each element and runs the code under each switch statement. The end goal here is to simplify the code to something like this:</p><pre><code class="js">//Code from switch &quot;4&quot;if (_0x1e92fd) &#123;try &#123;  _0x2e9a92[&quot;log&quot;] = _0x4e96ba[&quot;uLq&quot;](_0x19195e, _0x1e92fd);&#125; catch (_0x3fc75d) &#123;&#125;&#125;//Code from switch &quot;2&quot;if (!_0x530384[&quot;btoa&quot;]) _0x530384[&quot;btoa&quot;] = _0x48c673;//Code from switch &quot;3&quot;_0x4e96ba[&quot;gGv&quot;](_0x3abf6a);//Code from switch &quot;1&quot;_0x4bc649[&quot;push&quot;]([&quot;&#39;v8b33affa616d7e2343cc7cd58fb6cd20c99ad6b16413b7c5af014cfde3a957ad&#39;.toString()&quot;, &quot;value&quot;]);... etc</code></pre><p>And here is our resulting Babel plugin:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const flattenControlFlowVisitor = &#123;    SwitchStatement(path)&#123;        const &#123; node &#125; = path;        if(t.isMemberExpression(node.discriminant) &amp;&amp;            t.isIdentifier(node.discriminant.object) &amp;&amp;            t.isUpdateExpression(node.discriminant.property) &amp;&amp;            node.discriminant.property.operator === &quot;++&quot; &amp;&amp;            node.discriminant.property.prefix === false)        &#123;            //We&#39;re in the right switch statement            //Get the switch order variable name            //e.g.     var _0x48d663 = &quot;3|6|2|0|5|1|4&quot;[&quot;split&quot;](&quot;|&quot;), ---&gt; _0x48d663            const switchOrderVar = node.discriminant.object.name;            //Get the bindings of the variable and get the switch order into an array            const switchOrder = path.scope.getBinding(switchOrderVar).path.node.init.callee.object.value.split(&quot;|&quot;)            let orderedNodes = []            //Loop through the switch order            for(const sw of switchOrder)&#123;                //Get the switch cases that belong to the switch                const switchCase = path.node.cases.find(c =&gt; c.test.value === sw);                                //Get the nodes under the switch excluding the continue statement                const nodesInSwitchCase = switchCase.consequent.filter(c =&gt; !t.isContinueStatement(c))                                //Drop them into an array                //cloneDeepWithoutLoc to avoid issues!                orderedNodes.push(...nodesInSwitchCase.map(n =&gt; t.cloneDeepWithoutLoc(n)))            &#125;                        //Replace the parent while statement            const whileStatement = path.parentPath.parentPath;            whileStatement.replaceWithMultiple(orderedNodes);        &#125;    &#125;&#125;traverse(ast, flattenControlFlowVisitor);traverse(ast, flattenControlFlowVisitor); //Run it twice!</code></pre><p>You’ll notice that we need to run this visitor twice, this is because there are nested switch statements. One improvement that could be made to this visitor is to make it recursive. This would make it more efficient and mean that we don’t have to traverse the AST twice. We’ve now simplified the ugly control flow code into this:</p><pre><code class="js">function _0x4d748b(_0x1b013d) &#123;var _0x3a900f = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;var _0x2026be, _0x30a9be, _0x105a8e;var _0x337f59, _0x32ce20, _0x52c47a;_0x105a8e = _0x1b013d[&quot;length&quot;];_0x30a9be = 0x0;_0x2026be = &quot;&quot;;while (_0x388c13[&quot;wag&quot;](_0x30a9be, _0x105a8e)) &#123;  var _0x4a9695 = &quot;6|8|7|2|0|1|4|3|5&quot;[&quot;split&quot;](&quot;|&quot;),    _0x1a9326 = 0x0;  _0x337f59 = _0x388c13[&quot;YnZ&quot;](_0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++), 0xff);  if (_0x388c13[&quot;PNJ&quot;](_0x30a9be, _0x105a8e)) &#123;    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x337f59 &gt;&gt; 0x2);    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;fza&quot;](_0x388c13[&quot;yuG&quot;](_0x337f59, 0x3), 0x4));    _0x2026be += &quot;==&quot;;    break;  &#125;  _0x32ce20 = _0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++);  if (_0x388c13[&quot;PNJ&quot;](_0x30a9be, _0x105a8e)) &#123;    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;ydV&quot;](_0x337f59, 0x2));    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;AfV&quot;](_0x388c13[&quot;XCm&quot;](_0x337f59, 0x3) &lt;&lt; 0x4, (_0x32ce20 &amp; 0xf0) &gt;&gt; 0x4));    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;pYD&quot;](_0x32ce20, 0xf) &lt;&lt; 0x2);    _0x2026be += &quot;=&quot;;    break;  &#125;  _0x52c47a = _0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++);  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;Oed&quot;](_0x337f59, 0x2));  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;VuS&quot;](_0x388c13[&quot;jpt&quot;](_0x337f59, 0x3) &lt;&lt; 0x4, _0x388c13[&quot;ydV&quot;](_0x388c13[&quot;EML&quot;](_0x32ce20, 0xf0), 0x4)));  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;sWH&quot;](_0x32ce20 &amp; 0xf, 0x2) | _0x388c13[&quot;ydV&quot;](_0x388c13[&quot;uQC&quot;](_0x52c47a, 0xc0), 0x6));  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;EML&quot;](_0x52c47a, 0x3f));&#125;return _0x2026be;&#125;</code></pre><h2 id="Removing-Proxy-References"><a href="#Removing-Proxy-References" class="headerlink" title="Removing Proxy References"></a>Removing Proxy References</h2><p>The next obfuscation technique we’re going to tackle is proxy references. Proxy references are calls to functions that execute another function. The end goal here is to replace any calls to proxy functions with their intended function calls.</p><p>We can see examples of proxy calls in the code, e.g:</p><pre><code class="js">&quot;Pjt&quot;: function _0x1068f3(_0x1dcc0d, _0x4fccf2) &#123;  return _0x1dcc0d + _0x4fccf2;&#125;,</code></pre><p>Here we have a function that is defined as <code>Pjt</code>, and all this is doing is doing a simple addition on the two parameters.</p><p>First thing we need to do is traverse through the script and identify any objects that define the proxy functions. You’ll see that the proxy references are contained in an object like so:</p><pre><code class="js">var _0x388c13 = &#123;&quot;wag&quot;: function _0x67d457(_0x2f20be, _0x4a591a) &#123;  return _0x2f20be &lt; _0x4a591a;&#125;,</code></pre><p>The goal is to build a lookup table of the object variable name (<code>_0x388c13</code>) and all the proxy functions it contains. We can achieve this with this visitor:</p><pre><code class="js">this.proxyFuncVars = &#123;&#125;path.traverse(&#123;    ObjectProperty(path)&#123;        const &#123; node &#125; = path;        if (t.isFunctionExpression(node.value) &amp;&amp; t.isReturnStatement(node.value.body.body[0]))&#123;            //Found a proxy expression            const varDecl = path.getStatementParent()            if (!this.proxyFuncVars[varDecl.node.declarations[0].id.name]) &#123;                this.proxyFuncVars[varDecl.node.declarations[0].id.name] = [];            &#125;            this.proxyFuncVars[varDecl.node.declarations[0].id.name].push([node.key.value, node.value]);        &#125;    &#125;&#125;)</code></pre><p>We now have a lookup table that looks like this:</p><p><img src="/images/2.png" alt="image-20230306151919010"></p><p>The next thing that we need to do is traverse <code>CallExpressions</code> and see if it belongs in our lookup table. If it does, we can simply replace the <code>CallExpression</code> with the proxy function. Here is a visitor that does just that:</p><pre><code class="js">function findProxyFunction(lookupTable, varName, funcName)&#123;    for(const key of Object.keys(lookupTable))&#123;        if (key === varName)&#123;            for(const func of lookupTable[key])&#123;                if (func[0] === funcName)&#123;                    return func[1]                &#125;            &#125;        &#125;    &#125;    return null&#125;CallExpression(path)&#123;    const &#123; node &#125; = path;    if (        t.isMemberExpression(node.callee) &amp;&amp;        t.isIdentifier(node.callee.object) &amp;&amp;        findProxyFunction(this.proxyFuncVars, node.callee.object.name, node.callee.property.name)    )&#123;        const varName = node.callee.object.name;        const funcName =  node.callee.property.name;        const proxyFunc = findProxyFunction(this.proxyFuncVars, varName, funcName);        if (proxyFunc)&#123;            //We found a proxy function, so do a replacement            if (t.isBinaryExpression(proxyFunc.body.body[0].argument))&#123;                const funcBinaryExpression = proxyFunc.body.body[0].argument;                path.replaceWith(t.binaryExpression(funcBinaryExpression.operator, node.arguments[0], node.arguments[1]))            &#125; else if (t.isCallExpression(proxyFunc.body.body[0].argument))&#123;                const funcName = node.arguments.slice(1);                path.replaceWith(t.callExpression(node.arguments[0], funcName))            &#125;        &#125;    &#125;&#125;,</code></pre><blockquote><p><strong>Caution:</strong> The above code doesn’t consider the ordering of the arguments. For the utmvc script it’s not a problem since they’re always in order, however you should consider the argument positioning for other obfuscated code</p></blockquote><p>We’ve now transformed the code and removed all the proxy references!</p><p>Before:</p><pre><code class="js">_0x25c494[_0x25c494.length] = _0x5cf4da.bfY(_0x4ce1f7, _0x5cf4da.szJ(_0x412285, &quot;=undefined&quot;));</code></pre><p>After:</p><pre><code class="js">_0x25c494[_0x25c494.length] = _0x4ce1f7(_0x412285 + &quot;=undefined&quot;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deobfuscating Imperva&#39;s utmvc Anti-Bot Script - Part 1</title>
      <link href="/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot/"/>
      <url>/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>In this post, we’re going to take a deep dive into the utmvc challenge script that is part of the FlexProtect suite (formerly called Incapsula) by Imperva. The utmvc challenge is one of two challenge scripts that are presented to a user’s browser when browsing a protected site, the second being reese84. Depending on the setup of the site, the user’s browser will need to solve both the utmvc and reese84 challenge, and some sites will require only the reese84 challenge. It seems that the utmvc challenge is somewhat of a “legacy” challenge and has been superseded by the reese84 script.</p><p>The goal of this article is to fully de-obfuscate the utmvc script so that we can understand what it is doing, which can ultimately lead us to build a generator to mock&#x2F;spoof the values the script requires.</p><p>This article is going to use various well-known Javascript de-obfuscation techniques, including BabelJS. Unfortunately, the documentation for BabelJS is somewhat non-existent, so I will do my best to explain what is going on throughout this article. If you are new to BabelJS, I highly recommend this excellent series by PianoMan.</p><p>Ready? Let’s begin.</p><h2 id="Finding-the-script"><a href="#Finding-the-script" class="headerlink" title="Finding the script"></a>Finding the script</h2><p>For the purpose of this article, I am going to use the utmvc script that is served up on <a href="https://www.smythstoys.com/">SmythsToys</a>. Firstly, let’s open up <a href="https://www.charlesproxy.com/">Charles Proxy</a> so that we can inspect the network traffic. Then open up a browser, clear cookies, cache, local storage, and then browse to our target website. We can see a few requests to Incapsula-related resources. The one that looks of interest to us here is the <code>POST</code> to <code>_Incapsula_Resource</code>. If we have a look at the HTTP contents, we can see that the <code>___utmvc</code> cookie is sent to this endpoint.</p><p><img src="/images/1.png" alt="1.png"></p><p>If we have a look at the <code>GET</code> request to the same endpoint, we see something interesting <em>(truncated for abrevity)</em>…</p><pre><code class="js">(function() &#123;    var z = &quot;&quot;;    var b = &quot;766172205f3.....&quot;;    eval((function() &#123;        for (var i = 0; i &lt; b.length; i += 2) &#123;            z += String.fromCharCode(parseInt(b.substring(i, i + 2), 16));        &#125;        return z;    &#125;)());&#125;)();</code></pre><p>Let’s break it down.</p><p>What we have here is an Immediately Invoked Function Expression (IIFE). Basically, this block of code will be immediately executed when a user visits the webpage. Inside the IIFE, we have a variable called b, which contains a bunch of character codes. We then have a nested IIFE, which is wrapped around an <code>eval</code> call. The IIFE inside the eval is doing a very basic string decoder function. It’s looping through the characters in b, 2 at a time, and appending their ASCII equivalent values to the z variable.</p><h2 id="Decoding-the-script"><a href="#Decoding-the-script" class="headerlink" title="Decoding the script"></a>Decoding the script</h2><p>Now we have the code, we need to turn it into tangible Javascript code. Lets take the code from above and make a simpler decoder than will print out the decoded string to our console.</p><pre><code class="js">var b = &quot;766172205f3....&quot;var final = &quot;&quot;;for (var i = 0; i &lt; b.length; i += 2) &#123;  final += String.fromCharCode(parseInt(b.substring(i, i + 2), 16));&#125;console.log(final);</code></pre><p>So in our console we should now have the decoded string. It looks a bit scary at first, but if we run the output through a <a href="https://beautifier.io/">JS beautifier</a>, we get something that resembles somewhat recogniseable Javascript:</p><pre><code class="js">(function(_0x246fbc, _0x279367) &#123;    var _0x3ef8fa = function(_0x4e4813) &#123;        while (--_0x4e4813) &#123;            _0x246fbc[&#39;\x70\x75\x73\x68&#39;](_0x246fbc[&#39;\x73\x68\x69\x66\x74&#39;]());        &#125;    &#125;;    var _0x2247fc = function() &#123;        var _0x3108b4 = &#123;            &#39;\x64\x61\x74\x61&#39;: &#123;                &#39;\x6b\x65\x79&#39;: &#39;\x63\x6f\x6f\x6b\x69\x65&#39;,                &#39;\x76\x61\x6c\x75\x65&#39;: &#39;\x74\x69\x6d\x65\x6f\x75\x74&#39;            &#125;,            &#39;\x73\x65\x74\x43\x6f\x6f\x6b\x69\x65&#39;: function(_0x564ed7, _0x16e7cb, _0x1a47f2, _0x3f5a26) &#123;                _0x3f5a26 = _0x3f5a26 || &#123;&#125;;                var _0x7c508a = _0x16e7cb + &#39;\x3d&#39; + _0x1a47f2;                var _0x367e08 = 0x0;                for (var _0x367e08 = 0x0, _0x492c74 = _0x564ed7[&#39;\x6c\x65\x6e\x67\x74\x68&#39;]; _0x367e08 &lt; _0x492c74; _0x367e08++) &#123;                    var _0x2c0fa7 = _0x564ed7[_0x367e08];                    _0x7c508a += &#39;\x3b\x20&#39; + _0x2c0fa7;                    var _0x4478c3 = _0x564ed7[_0x2c0fa7];                    _0x564ed7[&#39;\x70\x75\x73\x68&#39;](_0x4478c3);                    _0x492c74 = _0x564ed7[&#39;\x6c\x65\x6e\x67\x74\x68&#39;];                    if (_0x4478c3 !== !![]) &#123;                        _0x7c508a += &#39;\x3d&#39; + _0x4478c3;                    &#125;                &#125;                _0x3f5a26[&#39;\x63\x6f\x6f\x6b\x69\x65&#39;] = _0x7c508a;            &#125;,            &#39;\x72\x65\x6d\x6f\x76\x65\x43\x6f\x6f\x6b\x69\x65&#39;: function() &#123;                return &#39;\x64\x65\x76&#39;;            &#125;,....</code></pre><p>Looking at the above, we can see that we have a few obfuscation techniques going on:</p><ul><li>Strings are protected by hexadecimal escape sequences (<code>\x</code> notation)</li><li>Variable names have been renamed to hexadecimal</li><li>Numbers have been replaced by their hexadecimal equivielent</li></ul><p>Just from experience, I know that these particular techniques are a result of <a href="https://obfuscator.io/">ObfuscatorIO</a>.</p><h2 id="Revealing-Strings"><a href="#Revealing-Strings" class="headerlink" title="Revealing Strings"></a>Revealing Strings</h2><p>As I mentioned previously, the strings are being represented by hexadecimal escape sequences, so we need to reveal and replaice them with their plaintext values. Luckily Babel provides a really easy way for us to do this. The plaintext value can be found in the <code>extra</code> property of the <code>StringLiteral</code> type:</p><p>And we can write a simple Babel visitor for this:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const ast = parser.parse(decoded);const revealStrings = &#123;  StringLiteral(path)&#123;    if (!path.node.extra) return;    path.replaceWith(t.stringLiteral(path.node.extra.rawValue))  &#125;&#125;traverse(ast, revealStrings);</code></pre><p>After we have run the above visitor, we’ve now reveleaed some of the strings, but we’re not fully done yet.</p><pre><code class="js"> var _0x2247fc = function () &#123;    var _0x3108b4 = &#123;      &quot;data&quot;: &#123;        &quot;key&quot;: &quot;cookie&quot;,        &quot;value&quot;: &quot;timeout&quot;      &#125;,      &quot;setCookie&quot;: function (_0x564ed7, _0x16e7cb, _0x1a47f2, _0x3f5a26) &#123;        _0x3f5a26 = _0x3f5a26 || &#123;&#125;;        var _0x7c508a = _0x16e7cb + &quot;=&quot; + _0x1a47f2;        var _0x367e08 = 0x0;        for (var _0x367e08 = 0x0, _0x492c74 = _0x564ed7[&quot;length&quot;]; _0x367e08 &lt; _0x492c74; _0x367e08++) &#123;          var _0x2c0fa7 = _0x564ed7[_0x367e08];          _0x7c508a += &quot;; &quot; + _0x2c0fa7;          var _0x4478c3 = _0x564ed7[_0x2c0fa7];          _0x564ed7[&quot;push&quot;](_0x4478c3);          _0x492c74 = _0x564ed7[&quot;length&quot;];          if (_0x4478c3 !== !![]) &#123;            _0x7c508a += &quot;=&quot; + _0x4478c3;</code></pre><p>So now we have all the strings in a readable format, but if we have a look in the script, we can still see that there are Base64 strings all over the place. Whilst some of the strings are now readable, there are still a lot of strings that aren’t. Throughout the script, there are repeated occurrences of this type of stuff: <code>_0xe3ea(&quot;0x44&quot;, &quot;@7QD&quot;)</code>, <code>_0xe3ea(&quot;0x4f&quot;, &quot;E@5e&quot;)</code> - a call expression with two parameters, a number represented as a hex string, and a string literal.</p><p>If we take a look at the function <code>_0xe3ea</code>, we can see references to “rc4”. RC4 is a symmetric stream cipher algorithm that is used for encrypting and decrypting strings. Again from experience, I know that RC4 string encryption is a feature of ObfuscatorIO. So based on this knowledge, can we assume that the <code>_0xe3ea</code> is an RC4 decoder function? Yes!</p><p>At the top of the script, we have a <code>VariableDeclaration</code>, which is initialized to an <code>ArrayExpression</code>. This again is a feature of ObfuscatorIO and is used to make reading strings harder. When you run code through ObfuscatorIO, it will take the strings, encrypt them using RC4, put them into an array and use a decoder function to find the correct string, decrypt it and return. We can write a visitor to store the values in an array:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;let wordArray = []const getWordArray = &#123;  Program(path)&#123;     wordArray = node.body[0].declarations[0].init.elements.map((val =&gt; val.value;));    path.stop();  &#125;&#125;traverse(ast, getWordArry);</code></pre><p>We now have an array of RC4 encrypted strings.</p><h2 id="Understanding-the-RC4-String-Encryption"><a href="#Understanding-the-RC4-String-Encryption" class="headerlink" title="Understanding the RC4 String Encryption"></a>Understanding the RC4 String Encryption</h2><h3 id="Word-Array-and-Shuffle"><a href="#Word-Array-and-Shuffle" class="headerlink" title="Word Array and Shuffle"></a>Word Array and Shuffle</h3><p>Before we get too far into the the RC4  encryption, we need to understand how the RC4 encrypted strings are stored in the script. Just above the RC4 decryption function, we have another IIFE:</p><pre><code class="js">(function (_0x246fbc, _0x279367) &#123;  var _0x3ef8fa = function (_0x4e4813) &#123;    while (--_0x4e4813) &#123;      _0x246fbc[&quot;push&quot;](_0x246fbc[&quot;shift&quot;]());    &#125;  &#125;;  var _0x2247fc = function () &#123;    var _0x3108b4 = &#123;      &quot;data&quot;: &#123;        &quot;key&quot;: &quot;cookie&quot;,        &quot;value&quot;: &quot;timeout&quot;      &#125;,      &quot;setCookie&quot;: function (_0x564ed7, _0x16e7cb, _0x1a47f2, _0x3f5a26) &#123;        _0x3f5a26 = _0x3f5a26 || &#123;&#125;;        var _0x7c508a = _0x16e7cb + &quot;=&quot; + _0x1a47f2;        var _0x367e08 = 0x0;        for (var _0x367e08 = 0x0, _0x492c74 = _0x564ed7[&quot;length&quot;]; _0x367e08 &lt; _0x492c74; _0x367e08++) &#123;          var _0x2c0fa7 = _0x564ed7[_0x367e08];          _0x7c508a += &quot;; &quot; + _0x2c0fa7;          var _0x4478c3 = _0x564ed7[_0x2c0fa7];          _0x564ed7[&quot;push&quot;](_0x4478c3);          _0x492c74 = _0x564ed7[&quot;length&quot;];          if (_0x4478c3 !== !![]) &#123;            _0x7c508a += &quot;=&quot; + _0x4478c3;          &#125;        &#125;        _0x3f5a26[&quot;cookie&quot;] = _0x7c508a;      &#125;,      &quot;removeCookie&quot;: function () &#123;        return &quot;dev&quot;;      &#125;,      &quot;getCookie&quot;: function (_0x230827, _0x3e3448) &#123;        _0x230827 = _0x230827 || function (_0x3772b8) &#123;          return _0x3772b8;        &#125;;        var _0x26af38 = _0x230827(new RegExp(&quot;(?:^|; )&quot; + _0x3e3448[&quot;replace&quot;](/([.$?*|&#123;&#125;()[]\/+^])/g, &quot;$1&quot;) + &quot;=([^;]*)&quot;));        var _0x4fd28d = function (_0x53e56d, _0xd00715) &#123;          _0x53e56d(++_0xd00715);        &#125;;        _0x4fd28d(_0x3ef8fa, _0x279367);        return _0x26af38 ? decodeURIComponent(_0x26af38[0x1]) : undefined;      &#125;    &#125;;    var _0x255171 = function () &#123;      var _0x5b8adf = new RegExp(&quot;\\w+ *\\(\\) *&#123;\\w+ *[&#39;|\&quot;].+[&#39;|\&quot;];? *&#125;&quot;);      return _0x5b8adf[&quot;test&quot;](_0x3108b4[&quot;removeCookie&quot;][&quot;toString&quot;]());    &#125;;    _0x3108b4[&quot;updateCookie&quot;] = _0x255171;    var _0xecc8a7 = &quot;&quot;;    var _0x586381 = _0x3108b4[&quot;updateCookie&quot;]();    if (!_0x586381) &#123;      _0x3108b4[&quot;setCookie&quot;]([&quot;*&quot;], &quot;counter&quot;, 0x1);    &#125; else if (_0x586381) &#123;      _0xecc8a7 = _0x3108b4[&quot;getCookie&quot;](null, &quot;counter&quot;);    &#125; else &#123;      _0x3108b4[&quot;removeCookie&quot;]();    &#125;  &#125;;  _0x2247fc();&#125;)(_0x3eae, 0x14a);</code></pre><p>This time the IFFE has two parameters: <code>_0x3eae</code> and <code>0x14a</code>. <code>_0x3eae</code> is the word array that we extracted above (an <code>ArrayExpression</code> of encrypted strings) and <code>0x14a</code> is a literal that has a numeric value of <code>330</code>. This number is important. The array of strings is out of order and this number is the ‘magic number’ which is used to shuffle the array to get them back in the correct order.</p><p>This is the shuffle code from the script:</p><pre><code class="js">var _0x3ef8fa = function (_0x4e4813) &#123;  while (--_0x4e4813) &#123;    _0x246fbc[&quot;push&quot;](_0x246fbc[&quot;shift&quot;]());  &#125;&#125;;</code></pre><p>But it can be re-written to something a bit easier to read:</p><pre><code class="js">function shuffleWordArray(array, num) &#123;  while (--num) &#123;    array.push(array.shift());  &#125;&#125;</code></pre><p>We now need to shuffle our encrypted string array by the magic number to ensure that the strings are in the correct order in the array:</p><pre><code class="js">//shuffle the array to ensure it&#39;s in the correct ordershuffleWordArray(wordArray, magicNumber);//wordArray is now in the correct order</code></pre><h3 id="RC4-Deep-Dive"><a href="#RC4-Deep-Dive" class="headerlink" title="RC4 Deep Dive"></a>RC4 Deep Dive</h3><p>This is the entire RC4 decoder function, I’ve added some comments to make it easier to understand:</p><pre><code class="js">var _0xe3ea = function (_0x246fbc, _0x279367) &#123;  _0x246fbc = _0x246fbc - 0x0;  //_0x3eae - This is our huge word array at the top of the script which contains all the RC4 encrypted strings  //_0x246fbc - This is an index getter for the array  var _0x3ef8fa = _0x3eae[_0x246fbc];    if (_0xe3ea[&quot;initialized&quot;] === undefined) &#123;    //A Base64 Encoder/Decoder    (function () &#123;      var _0x45df7b = Function(&quot;return (function () &quot; + &quot;&#123;&#125;.constructor(\&quot;return this\&quot;)()&quot; + &quot;);&quot;);      var _0x2247fc = _0x45df7b();      var _0x3108b4 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;      _0x2247fc[&quot;atob&quot;] || (_0x2247fc[&quot;atob&quot;] = function (_0x564ed7) &#123;        var _0x16e7cb = String(_0x564ed7)[&quot;replace&quot;](/=+$/, &quot;&quot;);        for (var _0x1a47f2 = 0x0, _0x3f5a26, _0x7c508a, _0x76115b = 0x0, _0x367e08 = &quot;&quot;; _0x7c508a = _0x16e7cb[&quot;charAt&quot;](_0x76115b++); ~_0x7c508a &amp;&amp; (_0x3f5a26 = _0x1a47f2 % 0x4 ? _0x3f5a26 * 0x40 + _0x7c508a : _0x7c508a, _0x1a47f2++ % 0x4) ? _0x367e08 += String[&quot;fromCharCode&quot;](0xff &amp; _0x3f5a26 &gt;&gt; (-0x2 * _0x1a47f2 &amp; 0x6)) : 0x0) &#123;          _0x7c508a = _0x3108b4[&quot;indexOf&quot;](_0x7c508a);        &#125;        return _0x367e08;      &#125;);    &#125;)();        //The actual RC4 encryption code, parameter 1 is the encrypted string, parameter 2 is the key    var _0x492c74 = function (_0x2c0fa7, _0x4478c3) &#123;      var _0x230827 = [],        _0x3e3448 = 0x0,        _0x3772b8,        _0x26af38 = &quot;&quot;,        _0x4fd28d = &quot;&quot;;      _0x2c0fa7 = atob(_0x2c0fa7);      for (var _0x53e56d = 0x0, _0xd00715 = _0x2c0fa7[&quot;length&quot;]; _0x53e56d &lt; _0xd00715; _0x53e56d++) &#123;        _0x4fd28d += &quot;%&quot; + (&quot;00&quot; + _0x2c0fa7[&quot;charCodeAt&quot;](_0x53e56d)[&quot;toString&quot;](0x10))[&quot;slice&quot;](-0x2);      &#125;      _0x2c0fa7 = decodeURIComponent(_0x4fd28d);      for (var _0x255171 = 0x0; _0x255171 &lt; 0x100; _0x255171++) &#123;        _0x230827[_0x255171] = _0x255171;      &#125;      for (_0x255171 = 0x0; _0x255171 &lt; 0x100; _0x255171++) &#123;        _0x3e3448 = (_0x3e3448 + _0x230827[_0x255171] + _0x4478c3[&quot;charCodeAt&quot;](_0x255171 % _0x4478c3[&quot;length&quot;])) % 0x100;        _0x3772b8 = _0x230827[_0x255171];        _0x230827[_0x255171] = _0x230827[_0x3e3448];        _0x230827[_0x3e3448] = _0x3772b8;      &#125;      _0x255171 = 0x0;      _0x3e3448 = 0x0;      for (var _0x5b8adf = 0x0; _0x5b8adf &lt; _0x2c0fa7[&quot;length&quot;]; _0x5b8adf++) &#123;        _0x255171 = (_0x255171 + 0x1) % 0x100;        _0x3e3448 = (_0x3e3448 + _0x230827[_0x255171]) % 0x100;        _0x3772b8 = _0x230827[_0x255171];        _0x230827[_0x255171] = _0x230827[_0x3e3448];        _0x230827[_0x3e3448] = _0x3772b8;        _0x26af38 += String[&quot;fromCharCode&quot;](_0x2c0fa7[&quot;charCodeAt&quot;](_0x5b8adf) ^ _0x230827[(_0x230827[_0x255171] + _0x230827[_0x3e3448]) % 0x100]);      &#125;      return _0x26af38;    &#125;;    _0xe3ea[&quot;rc4&quot;] = _0x492c74;    _0xe3ea[&quot;data&quot;] = &#123;&#125;;    _0xe3ea[&quot;initialized&quot;] = !![];  &#125;  var _0xecc8a7 = _0xe3ea[&quot;data&quot;][_0x246fbc];  if (_0xecc8a7 === undefined) &#123;    if (_0xe3ea[&quot;once&quot;] === undefined) &#123;      var _0x586381 = function (_0x3328ca) &#123;        this[&quot;rc4Bytes&quot;] = _0x3328ca;        this[&quot;states&quot;] = [0x1, 0x0, 0x0];        this[&quot;newState&quot;] = function () &#123;          return &quot;newState&quot;;        &#125;;        this[&quot;firstState&quot;] = &quot;\\w+ *\\(\\) *&#123;\\w+ *&quot;;        this[&quot;secondState&quot;] = &quot;[&#39;|\&quot;].+[&#39;|\&quot;];? *&#125;&quot;;      &#125;;      _0x586381[&quot;prototype&quot;][&quot;checkState&quot;] = function () &#123;        var _0x17ea7d = new RegExp(this[&quot;firstState&quot;] + this[&quot;secondState&quot;]);        return this[&quot;runState&quot;](_0x17ea7d[&quot;test&quot;](this[&quot;newState&quot;][&quot;toString&quot;]()) ? --this[&quot;states&quot;][0x1] : --this[&quot;states&quot;][0x0]);      &#125;;      _0x586381[&quot;prototype&quot;][&quot;runState&quot;] = function (_0x4355f3) &#123;        if (!Boolean(~_0x4355f3)) &#123;          return _0x4355f3;        &#125;        return this[&quot;getState&quot;](this[&quot;rc4Bytes&quot;]);      &#125;;      _0x586381[&quot;prototype&quot;][&quot;getState&quot;] = function (_0x27ff93) &#123;        for (var _0x55a624 = 0x0, _0xa7b380 = this[&quot;states&quot;][&quot;length&quot;]; _0x55a624 &lt; _0xa7b380; _0x55a624++) &#123;          this[&quot;states&quot;][&quot;push&quot;](Math[&quot;round&quot;](Math[&quot;random&quot;]()));          _0xa7b380 = this[&quot;states&quot;][&quot;length&quot;];        &#125;        return _0x27ff93(this[&quot;states&quot;][0x0]);      &#125;;      new _0x586381(_0xe3ea)[&quot;checkState&quot;]();      _0xe3ea[&quot;once&quot;] = !![];    &#125;    _0x3ef8fa = _0xe3ea[&quot;rc4&quot;](_0x3ef8fa, _0x279367);    _0xe3ea[&quot;data&quot;][_0x246fbc] = _0x3ef8fa;  &#125; else &#123;    _0x3ef8fa = _0xecc8a7;  &#125;  return _0x3ef8fa;&#125;;</code></pre><p>Inside the RC4 code, we can see this: <code>_0xe3ea[&quot;rc4&quot;] = _0x492c74;</code>. What this tells us is that the the actual RC4 decryption function is defined in <code>_0x492c74</code>. If we have a look at <code>_0x492c74</code> we can see that it takes two parameters; lets assume the first parameter is the encrypted string and the second parameter is the decryption key.  Next we can isolate the RC4 function and pull it out so we can use it as a a standalone piece of code later. Again we can write a simple Babel plugin to extract the function:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;let rc4Function;const findRc4Function = &#123;  AssignmentExpression(path)&#123;     const &#123; node &#125; = path;        // Find the &#39;_0xe3ea[&quot;rc4&quot;] = _0x492c74;&#39; node    if (t.isMemberExpression(node.left) &amp;&amp;       node.left.property.value === &quot;rc4&quot;     ) &#123;      // Go back 1 node and get the RC4 function      rc4Function = path.getStatementParent().getPrevSibling();      path.stop();    &#125;  &#125;&#125;traverse(ast, findRc4Function);</code></pre><p>You can see what the code looks like by using the <code>generate</code> function:</p><pre><code class="js">const generatedCode = generate(rc4Function.node).codeconsole.log(generatedCode);// OUTPUT BELOWvar _0x2e9201 = function (_0x22a61c, _0x3e557b) &#123;  var _0x4eaa1b = [],    _0xa3379e = 0x0,    _0x48c4b8,    _0x27e820 = &quot;&quot;,    _0x2afcf0 = &quot;&quot;;  _0x22a61c = atob(_0x22a61c);  for (var _0x3f2921 = 0x0, _0x358e09 = _0x22a61c[&quot;length&quot;]; _0x3f2921 &lt; _0x358e09; _0x3f2921++) &#123;    _0x2afcf0 += &quot;%&quot; + (&quot;00&quot; + _0x22a61c[&quot;charCodeAt&quot;](_0x3f2921)[&quot;toString&quot;](0x10))[&quot;slice&quot;](-0x2);  &#125;  _0x22a61c = decodeURIComponent(_0x2afcf0);  for (var _0x5d8355 = 0x0; _0x5d8355 &lt; 0x100; _0x5d8355++) &#123;    _0x4eaa1b[_0x5d8355] = _0x5d8355;  &#125;  for (_0x5d8355 = 0x0; _0x5d8355 &lt; 0x100; _0x5d8355++) &#123;    _0xa3379e = (_0xa3379e + _0x4eaa1b[_0x5d8355] + _0x3e557b[&quot;charCodeAt&quot;](_0x5d8355 % _0x3e557b[&quot;length&quot;])) % 0x100;    _0x48c4b8 = _0x4eaa1b[_0x5d8355];    _0x4eaa1b[_0x5d8355] = _0x4eaa1b[_0xa3379e];    _0x4eaa1b[_0xa3379e] = _0x48c4b8;  &#125;  _0x5d8355 = 0x0;  _0xa3379e = 0x0;  for (var _0x40cbb7 = 0x0; _0x40cbb7 &lt; _0x22a61c[&quot;length&quot;]; _0x40cbb7++) &#123;    _0x5d8355 = (_0x5d8355 + 0x1) % 0x100;    _0xa3379e = (_0xa3379e + _0x4eaa1b[_0x5d8355]) % 0x100;    _0x48c4b8 = _0x4eaa1b[_0x5d8355];    _0x4eaa1b[_0x5d8355] = _0x4eaa1b[_0xa3379e];    _0x4eaa1b[_0xa3379e] = _0x48c4b8;    _0x27e820 += String[&quot;fromCharCode&quot;](_0x22a61c[&quot;charCodeAt&quot;](_0x40cbb7) ^ _0x4eaa1b[(_0x4eaa1b[_0x5d8355] + _0x4eaa1b[_0xa3379e]) % 0x100]);  &#125;  return _0x27e820;&#125;;</code></pre><p>We now have the RC4 decryption function isolated by itself. We don’t need to deobfuscate this any further as we don’t really care about the internals of this function, only what it produces. If you re-call from earlier, I said that we saw this type of code all over the place: <code>_0xe3ea(&quot;0x44&quot;, &quot;@7QD&quot;)</code>. We’ve now discovered that the RC4 decryption function is nested inside <code>_0xe3ea</code>, and <code>_0xe3ea</code> is a “getter” that internally calls the RC4 function and spits out the decrypted value. At the top of the getter we can see a reference with an index to our word array (<code>_0x3eae</code>). What this code is doing is fetching the encrypted string from our array, and then sending it to the RC4 decrypter. This is why it was important for us to shuffle the array before we got to this stage, otherwise we’d get the wrong decrypted string back!</p><pre><code class="js">var _0xe3ea = function (_0x246fbc, _0x279367) &#123;  _0x246fbc = _0x246fbc - 0x0;  var _0x3ef8fa = _0x3eae[_0x246fbc]; // &lt;&lt; This is a reference to the word arary with an index</code></pre><h3 id="Putting-it-together"><a href="#Putting-it-together" class="headerlink" title="Putting it together"></a>Putting it together</h3><p>We now have all the information we need to create our next Babel visitor, which will be used to replace the encrypted strings. We have the following knowledge:</p><ul><li>An array of encrypted strings (shuffled to be in the correct order)</li><li>A reference to the RC4 function</li><li>The identifier name of the <code>VariableDeclarator</code> which contains the array of strings</li><li>The “getter” fuction identifier which calls the RC4 function internally</li></ul><p>We can use <code>vm</code> to create a small context spearate from our main code, which will execute and return a value. We’re going to setup a context which contains just the RC4 code, call it from our visitor, and do a replacement:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const generate = require(&quot;@babel/generator&quot;).default;const vm = require(&quot;vm&quot;);function atob(a) &#123;    return new Buffer(a, &#39;base64&#39;).toString(&#39;binary&#39;);&#125;;const revealStringsVisitor = &#123;    AssignmentExpression(path)&#123;      const &#123; node &#125; = path;      if (          t.isMemberExpression(node.left) &amp;&amp;          node.left.property.value === &quot;rc4&quot;      )&#123;          // This is a variable to a function, i.e.  var _0x1cb434 = function (_0xc7576, _0x14cfd3) &#123; .. rc4 stuff          const rc4FuncVariableDeclaration = path.getStatementParent().getPrevSibling();                    // This is a &quot;getter&quot; that calls the RC4 function, i.e. the outer function          const getterFunction = rc4FuncVariableDeclaration.getFunctionParent().getStatementParent()          // The word array identifier          // var _0x3ef8fa = _0x3eae[_0x246fbc];          const arrayName = getterFunction.get(&quot;declarations.0.init.body&quot;).node.body[1].declarations[0].init.object.name;          const decoderFuncName = getterFunction.node.declarations[0].id.name;          //Setup a context with atob          const ctx = &#123;atob: atob&#125;          vm.runInNewContext(generate(rc4FuncVariableDeclaration.node).code, ctx);          const binding = path.scope.getBinding(decoderFuncName);          // Find all references to the decoder, i.e. _0xe3ea(&quot;0x44&quot;, &quot;@7QD&quot;)          for(const ref of binding.referencePaths)&#123;              if (                  t.isIdentifier(ref.parentPath.node.callee) &amp;&amp;                  t.isCallExpression(ref.parentPath) &amp;&amp;                  ref.parentPath.node.arguments.length === 2 &amp;&amp;                  ref.parentPath.node.arguments[0].type === &quot;StringLiteral&quot; &amp;&amp;                  ref.parentPath.node.arguments[1].type === &quot;StringLiteral&quot;              ) &#123;                  // Index is the first parameter, and lets conver to an int                  const index = parseInt(ref.parentPath.node.arguments[0].value);                  // Key is the 2nd parameter                  const key = ref.parentPath.node.arguments[1].value;                  // Call the RC4 decryption function inside the context, and get the output                  // Remember we already shuffled the wordArray earlier, so it is in the correct order now!                  const decryptedValue = ctx[rc4FuncVariableDeclaration.node.declarations[0].id.name](wordArray[index], key)                  // Do a plain text replacement                  ref.parentPath.replaceWith(t.valueToNode(decryptedValue));              &#125;          &#125;      &#125;  &#125; &#125;</code></pre><p>After running this plugin, we now have all strings revelaed!</p><pre><code class="js">...  var _0x19a5d8 = this[&quot;window&quot;];var _0x145c56 = _0x19a5d8[&quot;document&quot;];var _0xc68334 = &quot;&quot;;var _0x641c3c = &quot;&quot;;if (_0x2f96a5[&quot;yEQ&quot;](typeof _0x19a5d8[&quot;console&quot;], &quot;undefined&quot;)) &#123;  _0xc68334 = _0x19a5d8[&quot;console&quot;];  _0x641c3c = _0xc68334[&quot;log&quot;];&#125;var _0x2b232b = _0x19a5d8[&quot;navigator&quot;];var _0x35da0a = _0x19a5d8[&quot;encodeURIComponent&quot;];var _0x3ed2cd = new _0x19a5d8[&quot;Date&quot;]()[&quot;getTime&quot;]();...</code></pre><p>That’s it for part 1, and just to re-cap we have now successfully:</p><ul><li>Understood how to decode the intial script into something more readable</li><li>Removed the <code>\x</code> string notation</li><li>Replaced all strings with their unencrypted plain-text values</li></ul><p>In the next part, we’ll have a look at flattening the control flow of the script</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Reversing - Finding the RSA Key of Akamai BMP</title>
      <link href="/2023/03/04/Finding-Akamai-BMP-RSA-Key/"/>
      <url>/2023/03/04/Finding-Akamai-BMP-RSA-Key/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>This article I am going to show you how you can use various tools to reverse engineer Android applications. The goal of this article will be to reverse engineer an Android application that uses Akamai’s Bot Manager Premier (BMP), aka the mobile protection SDK. You can recognise this from the <code>x-acf-sensor-data</code> header that is sent with requests.</p><h2 id="The-Android-OS-and-Dalvik-Bytecode"><a href="#The-Android-OS-and-Dalvik-Bytecode" class="headerlink" title="The Android OS and Dalvik Bytecode"></a>The Android OS and Dalvik Bytecode</h2><p>Android is built on a modified version of the Linux kernel and is open-source. One of the key components of the Android OS is the Dalvik virtual machine, which is responsible for running applications written in Java or Kotlin. When an Android application is compiled, the Java code is converted into Dalvik bytecode, which is a set of low-level instructions (think of it like assembly for Windows), that can be executed by the Dalvik virtual machine. The Dalvik bytecode is optimised for use on mobile devices with limited processing power and memory, which ultimately allows apps to run efficiently on a wide range of devices</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>We’re going to need the following tools for this exercise:</p><ul><li>jadx - <a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a></li><li>Ghidra - <a href="https://github.com/NationalSecurityAgency/ghidra/release">https://github.com/NationalSecurityAgency/ghidra/release</a></li><li>apktool - <a href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a></li><li>Frida - <a href="https://frida.re/docs/android/">https://frida.re/docs/android/</a></li><li>An APK that has Akamai BMP (for this I’ll be using the <a href="https://play.google.com/store/apps/details?id=de.apptiv.business.android.aldi_uk&hl=en_GB&gl=US">Aldi APK</a>)</li></ul><p>The first thing we want to do is ensure that our target actually has Akamai BMP installed. The easiest way to do this is to open the APK in jadx, and search for the <code>x-acf-sensor-data</code> string:</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/3.png" alt="image-20230309180017125"></h2><p>Great, this is a valid target. The next thing we need to do is decompile the APK. The structure of an APK is organized into several directories and files. The root directory contains files such as the manifest file, which provides information about the app’s components, permissions, and metadata. The assets directory contains static files such as images and sound files. The <code>lib</code> directory contains compiled libraries that are specific to a particular CPU architecture. The res directory contains resources such as strings, layouts, and drawables that are used by the app’s user interface. The classes.dex file contains the app’s compiled code in the form of Dalvik bytecode.</p><h1 id="Decompiling-the-APK"><a href="#Decompiling-the-APK" class="headerlink" title="Decompiling the APK"></a>Decompiling the APK</h1><p>To decompile the APK we will use <code>apktool</code> :  <code>java -jar apktool_2.5.0.jar d &quot;ALDI UK_7.9.0.124_Apkpure.apk&quot;</code></p><p>After we’ve ran <code>apktool</code> we will have a folder with all the decompiled parts of the APK</p><p><img src="/images/4.png" alt="image-20230321234428989"></p><p>If we take a look in the <code>lib</code> folder we can find the compiled <code>.so</code> binaries for Akamai; <code>lib\x86_64\libakamaibmp.so</code></p><h1 id="Native-Library-Analysis"><a href="#Native-Library-Analysis" class="headerlink" title="Native Library Analysis"></a>Native Library Analysis</h1><p>We are next going to analyze the <code>.so</code> native library file. <code>.so</code> is the equivalent of a Dynamic Link Library (<code>.dll</code>) on Windows. To analyze this file we will use Ghidra. This is also often referred to as a shared library. Open up Ghidra and drag in the file so we can start the analysis process.</p><p><img src="/images/5.png" alt="image-20230322000553178"></p><p>If we go back to JADX and have a look at this code, we can see the references to some functions inside the shared object file.</p><pre><code class="java">package com.cyberfend.cyfsecurity;import android.util.Pair;import java.util.ArrayList;/* loaded from: classes.dex */public final class SensorDataBuilder &#123;    /* renamed from: a */    private static final SensorDataBuilder f387a = new SensorDataBuilder();    public final native synchronized String buildN(ArrayList&lt;Pair&lt;String, String&gt;&gt; arrayList);    public final native synchronized void initializeKeyN();    SensorDataBuilder() &#123;    &#125;    static &#123;        System.loadLibrary(&quot;akamaibmp&quot;);    &#125;    /* renamed from: a */    public static SensorDataBuilder m5136a() &#123;        return f387a;    &#125;    /* renamed from: com.cyberfend.cyfsecurity.SensorDataBuilder$1 */    /* loaded from: classes.dex */    final class AnonymousClass1 implements Runnable &#123;        /* JADX INFO: Access modifiers changed from: package-private */        public AnonymousClass1() &#123;        &#125;        @Override // java.lang.Runnable        public final void run() &#123;            SensorDataBuilder.this.initializeKeyN();        &#125;    &#125;&#125;</code></pre><p>We can see that native functions are called: <code>buildN</code> and <code>initializeKeyN</code>. This must mean that the shared library exports these functions to make them available in Java. If we go back to Ghidra, we can search for these functions in the symbol tree:</p><p><img src="/images/6.png" alt="image-20230322001140993"></p><p>Double clicking on the pink text under exports will decompile the function into pseudo-c</p><pre><code class="c">void Java_com_cyberfend_cyfsecurity_SensorDataBuilder_initializeKeyN(void)&#123;  int iVar1;  uchar **ppuVar2;  uchar *puVar3;  long in_FS_OFFSET;  uchar *puStack88;  uchar *apuStack80 [2];  void *pvStack64;  Crypto CStack56;  uchar auStack55 [15];  uchar *puStack40;  long lStack32;    ppuVar2 = (uchar **)SensorDataBuilder::getInstance();  lStack32 = *(long *)(in_FS_OFFSET + 0x28);  if (*(char *)(ppuVar2 + 5) == &#39;\0&#39;) &#123;    puVar3 = (uchar *)operator.new[](0x11);    *ppuVar2 = puVar3;    Crypto::randomBytes(0x10,ppuVar2);    std::__ndk1::basic_string&lt;char,std::__ndk1::char_traits&lt;char&gt;,std::__ndk1::allocator&lt;char&gt;&gt;::    basic_string&lt;decltype(nullptr)&gt;              ((basic_string&lt;char,std::__ndk1::char_traits&lt;char&gt;,std::__ndk1::allocator&lt;char&gt;&gt; *)               apuStack80,               &quot;-j0ZOfGt%xoJ$.p%U&lt;#~.Bnx#M\nk?-%PwI&amp;Yg+&gt;#|;0W1F&#123;?0@WVJE+#8d 6]Jy2V2_&lt;uqM:HbEfN8j/fy, L^(Prg&#125;yLPi^Xp&amp;ot43flfpXu`h AmT).TJ;*fdo^f;G@J84LcY!U-QKo[:]Be5)h&gt;v6HN*rjS,^|*&lt;K+(6|| yxRxH:S#4&gt;FSYVwK=z&lt;_SH&amp;*L+qWor+.fNpo_Q@o_8@t&#123;KAqQxc#Z(%X,r^[q)~*;+b8Plb&lt;Mrc\n8(&amp;U++!| Z8HPGT5oa/BqAbX6&quot;              );    Crypto::rotate_string(&amp;CStack56,(basic_string *)apuStack80,0x3f,-1);    if (((ulong)apuStack80[0] &amp; 1) != 0) &#123;      operator.delete(pvStack64);    &#125;....</code></pre><p>The first thing that immediately jumps out is the reference to another function: <code>rotate_string</code> which takes 3 parameters. <code>&amp;CStack56</code> is likely a pointer to to an instance of the <code>Crypto</code> class, <code>0x3f</code> is the rotation value (in this case <code>63</code>) and the third parameter <code>-1</code> could indicate the rotation direction.</p><p>If we double click the <code>rotate_string</code> function, we again get pseudo-c code for the function. We could try and reverse engineer this code, but it’s quite complicated with a lot of bit-shifting type code and memory allocation. Instead we can find another attack vector that will make our lives a lot easier, which I’ll explain below.</p><pre><code class="c">Crypto::rotate_string(Crypto *this,basic_string *param_1,uint param_2,int param_3)&#123;  char cVar1;  undefined *puVar2;  ulong uVar3;  ulong uVar4;  int iVar5;  ulong uVar6;  basic_string *pbVar7;  basic_string bVar8;  long lVar9;  ulong uVar10;  long in_FS_OFFSET;  bool bVar11;  undefined local_178 [4];  undefined4 uStack372;  undefined8 uStack368;  undefined *local_168;  undefined local_158 [8];  ulong uStack336;  undefined *local_148;  undefined local_138 [16];  undefined local_128 [16];  undefined local_118 [16];...  local_48 = local_138;  do &#123;    cVar1 = (char)lVar9;    if ((0x3a &lt; (byte)(cVar1 - 0x22U)) ||       ((0x400000000000021U &gt;&gt; ((ulong)(byte)(cVar1 - 0x22U) &amp; 0x3f) &amp; 1) == 0)) &#123;      if (cVar1 == &#39;\x7f&#39;) break;      bVar11 = (_local_158 &amp; (undefined  [16])0x1) != (undefined  [16])0x0;      if (bVar11) &#123;        uVar3 = (local_158 &amp; 0xfffffffffffffffe) - 1;      &#125;      else &#123;        uStack336 = (ulong)((byte)local_158[0] &gt;&gt; 1);        uVar3 = 0x16;      &#125;      local_138[lVar9] = (char)uStack336;      if (uStack336 == uVar3) &#123;                    /* try &#123; // try from 001a868f to 001a86ac has its CatchHandler @ 001a8955 */...</code></pre><p>So it looks as if this function is designed to decode&#x2F;decrypt a string, and there is some interesting text that we need to decode.</p><p>Again looking at the pseudo-c code of <code>initializeKeyN</code> we can see that the decoded string is later passed as a pointer parameter in a function called <code>RSAEncrypt</code> (look at <code>apuStack80</code>).</p><pre><code class="c">    basic_string&lt;decltype(nullptr)&gt;              ((basic_string&lt;char,std::__ndk1::char_traits&lt;char&gt;,std::__ndk1::allocator&lt;char&gt;&gt; *)               apuStack80,               &quot;-j0ZOfGt%xoJ$.p%U&lt;#~.Bnx#M\nk?-%PwI&amp;Yg+&gt;#|;0W1F&#123;?0@WVJE+#8d 6]Jy2V2_&lt;uqM:HbEfN8j/fy, L^(Prg&#125;yLPi^Xp&amp;ot43flfpXu`h AmT).TJ;*fdo^f;G@J84LcY!U-QKo[:]Be5)h&gt;v6HN*rjS,^|*&lt;K+(6|| yxRxH:S#4&gt;FSYVwK=z&lt;_SH&amp;*L+qWor+.fNpo_Q@o_8@t&#123;KAqQxc#Z(%X,r^[q)~*;+b8Plb&lt;Mrc\n8(&amp;U++!| Z8HPGT5oa/BqAbX6&quot;              );    Crypto::rotate_string(&amp;CStack56,(basic_string *)apuStack80,0x3f,-1);    if (((ulong)apuStack80[0] &amp; 1) != 0) &#123;      operator.delete(pvStack64);    &#125;    apuStack80[0] = (uchar *)operator.new[](0x81);    puVar3 = auStack55;    if (((byte)CStack56 &amp; 1) != 0) &#123;      puVar3 = puStack40;    &#125;    iVar1 = Crypto::RSAEncrypt(puVar3,0x10,*ppuVar2,apuStack80);</code></pre><p>If we double click the <code>RSAEncrypt</code> function, we can see that it is a function that accepts 4 parameters: a pointer, int, pointer and pointer to a pointer. This will be our alternative attack vector.</p><p><code>int Crypto::RSAEncrypt(uchar *param_1,int param_2,uchar *param_3,uchar **param_4)</code></p><p>The parameter we’re interested in is the <code>param_1</code>, as this is going to be the decrypted string value that is decoded by the <code>rotate_string</code> function.</p><h1 id="Hooking-Native-Functions-using-Frida"><a href="#Hooking-Native-Functions-using-Frida" class="headerlink" title="Hooking Native Functions using Frida"></a>Hooking Native Functions using Frida</h1><p>Okay so we know that we want to somehow read the value of the <code>param_1</code> pointer. We can us Frida to do just that. I am going to assume that you have already setup a rooted Android device and installed Frida on your device. We’re now going to write a Frida hook in JS that will hook into the native function of <code>RSAEncryprt</code>, intercept the parameters and dump it to the console.</p><p>We first create our basic <code>hook.js</code> file:</p><pre><code class="js">console.log(&quot;Started&quot;);function waitForLibLoading(libraryName) &#123;    var isLibLoaded = false;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function (args) &#123;            var libraryPath = Memory.readCString(args[0]);            if (libraryPath.includes(libraryName)) &#123;                console.log(&quot;[+] Loading library &quot; + libraryPath + &quot;...&quot;);                isLibLoaded = true;            &#125;        &#125;,        onLeave: function (args) &#123;            if (isLibLoaded) &#123;                                isLibLoaded = false;            &#125;        &#125;    &#125;);&#125;waitForLibLoading(&quot;libakamaibmp.so&quot;);</code></pre><p>This code will hook the <code>android_dlopen_ext</code> API call, which is the Dynamic Linker on Android. The Dynamic Linker on Android is responsible for resolving dependencies between shared libraries at runtime. When an application loads a shared library with <code>android_dlopen_ext</code>, the Dynamic Linker checks the library’s dependencies and recursively loads any additional libraries required by the application. The linker then resolves symbol references between the libraries, allowing the application to use functions and data defined in the shared libraries.</p><p>So we’ve now hooked the Dynamic Linker and have found where <code>libakamaibmp</code> has been loaded. The next step is we need to find the memory address of the library and also the memory address of the <code>RSAEncrypt</code> function, so we can read the memory locations.</p><p>If we search for <code>RSAEncrypt</code> in the Symbol Tree, we can see it’s virtual memory address in Ghidra. In our case the address is <code>0x001a4258</code>. This address isn’t quite correct just yet. </p><p><img src="/images/10.png" alt="image-20230322112310046"></p><p>We now need to find the Base Image Address. When a program is loaded into memory, the operating system assigns it a base image address where it’s code and data will be located, and is fixed  (for the most part) for the duration of programs execution. The Base Image Address is used as an offset for all memory references made by the program. For example, if a program tries to access a memory location at offset <code>0x1000</code> and it’s Base Image Address is <code>0x80000000</code>, the actual physical memory location address being access will be <code>0x80001000</code>.</p><p>To get the Base Image Address of this particular shared library, you can grab it from Ghidra by clicking Window -&gt; Memory Map. In this case, the Base Image Address is <code>0x001000000</code></p><p><img src="/images/9.png" alt="image-20230322110858847"></p><p>We can now write the following Frida code to find the correct memory location of <code>RSAEncrypt</code></p><pre><code class="js">function process(libraryName)&#123;    const rsaEncryptAddress = 0x001a4258    const imageBase = 0x00100000    const memBase = Module.findBaseAddress(libraryName);    console.log(&quot;-&gt; Base address is &quot; + memBase);    //Find the actual address by subtracting the image base    const actualRsaEncryptAddress = memBase.add(rsaEncryptAddress - imageBase);    console.log(&quot;[+] RSAEncrypt Physical Address &quot; + actualRsaEncryptAddress);&#125;</code></pre><p>We now have the physical address of <code>RSAEncrypt</code> as it’s loaded in memory. Next we need to write a hook to intercept the function and it’s parameters. Remember I mentioned earlier that the first parameter of <code>RSAEncrypt</code> is the plain-text RSA key, so we can hook that parameter and read it as a UTF-8 string.</p><pre><code class="js">Interceptor.attach(actualRsaEncryptAddress, &#123;    onEnter: function(args) &#123;        console.log(&quot;Hooked RSAEncrypt&quot;);        const rsaPublicKey = Memory.readUtf8String(args[0]); //public key is the first arg, and is type uchar *        console.log(rsaPublicKey);    &#125;,    onLeave: function(retval) &#123;        console.log(&quot;Leaving RSAEncrypt&quot;);    &#125;&#125;);    </code></pre><p>If we now put all this together and run the code in Frida, we can see the results!</p><p><code>frida -l hook.js -U -f de.apptiv.business.android.aldi_uk</code></p><p><img src="/images/8.png" alt="image-20230322112515124"></p><p>And here’s our final code:</p><pre><code class="js">console.log(&quot;Started&quot;);function process(libraryName)&#123;    const rsaEncryptAddress = 0x001a4258    const imageBase = 0x00100000    const memBase = Module.findBaseAddress(libraryName);    console.log(&quot;-&gt; Base address is &quot; + memBase);    //Find the actual address by subtracting the image base    const actualRsaEncryptAddress = memBase.add(rsaEncryptAddress - imageBase);    console.log(&quot;[+] Actual RSA Encrypt Address &quot; + actualRsaEncryptAddress);        Interceptor.attach(actualRsaEncryptAddress, &#123;        onEnter: function(args) &#123;            console.log(&quot;Hooked RSAEncrypt&quot;);            const rsaPublicKey = Memory.readUtf8String(args[0]); //public key is the first arg, and is type uchar *            console.log(rsaPublicKey);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;Leaving RSAEncrypt&quot;);        &#125;    &#125;);&#125;function waitForLibLoading(libraryName) &#123;    var isLibLoaded = false;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function (args) &#123;            var libraryPath = Memory.readCString(args[0]);            if (libraryPath.includes(libraryName)) &#123;                console.log(&quot;[+] Loading library &quot; + libraryPath + &quot;...&quot;);                isLibLoaded = true;            &#125;        &#125;,        onLeave: function (args) &#123;            if (isLibLoaded) &#123;                            process(libraryName);                isLibLoaded = false;            &#125;        &#125;    &#125;);&#125;waitForLibLoading(&quot;libakamaibmp.so&quot;);</code></pre><h2 id="Going-One-Step-Further"><a href="#Going-One-Step-Further" class="headerlink" title="Going One Step Further"></a>Going One Step Further</h2><p>Akamai BMP uses AES to encrypt sensors, which is also handled in the shared library. Further digging around in Ghidra we find another function of interest: <code>AESEncrypt</code></p><p><img src="/images/12.png" alt="image-20230322113338426"></p><p>We can take the information we’ve learnt from this article to apply the same theory to this function:</p><ol><li>Find the virtual address of the function</li><li>Translate it to a physical address</li><li>Build a hook</li><li>Profit!</li></ol><pre><code class="js">//AESEncrypt Hook (encrypts the sensor)const aesEncryptAddr = 0x001a3ff4; //Address of the AESEncrypt method, as found in Ghidraconst aesEncryptBase = Module.findBaseAddress(libraryName);console.log(&quot;[+] AESEncrypt Base address is &quot; + aesEncryptBase);const actualAesEncryptAddress = membase.add(aesEncryptAddr - ghidraImageBase);console.log(&quot;[+] Actual AESEncrypt Address &quot; + actualAesEncryptAddress);Interceptor.attach(actualAesEncryptAddress, &#123;    onEnter: function(args) &#123;        console.log(&quot;Hooked AESEncrypt&quot;);        const plainSensor = Memory.readUtf8String(args[0]); //sensor is the first arg, and is type uchar *        console.log(plainSensor);    &#125;,    onLeave: function(retval) &#123;        console.log(&quot;Leaving AESEncrypt&quot;);    &#125;&#125;);</code></pre><p>And we can see the results in our console!</p><p><img src="/images/11.png" alt="image-20230322113605443"></p><p>Until next time!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
