<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deobfuscating Imperva&#39;s utmvc Anti-Bot Script - Part 1</title>
      <link href="/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot/"/>
      <url>/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>In this post, we’re going to take a deep dive into the utmvc challenge script that is part of the FlexProtect suite (formerly called Incapsula) by Imperva. The utmvc challenge is one of two challenge scripts that are presented to a user’s browser when browsing a protected site, the second being reese84. Depending on the setup of the site, the user’s browser will need to solve both the utmvc and reese84 challenge, and some sites will require only the reese84 challenge. It seems that the utmvc challenge is somewhat of a “legacy” challenge and has been superseded by the reese84 script.</p><p>The goal of this article is to fully de-obfuscate the utmvc script so that we can understand what it is doing, which can ultimately lead us to build a generator to mock&#x2F;spoof the values the script requires.</p><p>This article is going to use various well-known Javascript de-obfuscation techniques, including BabelJS. Unfortunately, the documentation for BabelJS is somewhat non-existent, so I will do my best to explain what is going on throughout this article. If you are new to BabelJS, I highly recommend this excellent series by PianoMan.</p><p>Ready? Let’s begin.</p><h2 id="Finding-the-script"><a href="#Finding-the-script" class="headerlink" title="Finding the script"></a>Finding the script</h2><p>For the purpose of this article, I am going to use the utmvc script that is served up on <a href="https://www.smythstoys.com/">SmythsToys</a>. Firstly, let’s open up <a href="https://www.charlesproxy.com/">Charles Proxy</a> so that we can inspect the network traffic. Then open up a browser, clear cookies, cache, local storage, and then browse to our target website. We can see a few requests to Incapsula-related resources. The one that looks of interest to us here is the <code>POST</code> to <code>_Incapsula_Resource</code>. If we have a look at the HTTP contents, we can see that the <code>___utmvc</code> cookie is sent to this endpoint.</p><p><img src="/images/1.png" alt="1.png"></p><p>If we have a look at the <code>GET</code> request to the same endpoint, we see something interesting <em>(truncated for abrevity)</em>…</p><pre><code class="js">(function() &#123;    var z = &quot;&quot;;    var b = &quot;766172205f3.....&quot;;    eval((function() &#123;        for (var i = 0; i &lt; b.length; i += 2) &#123;            z += String.fromCharCode(parseInt(b.substring(i, i + 2), 16));        &#125;        return z;    &#125;)());&#125;)();</code></pre><p>Let’s break it down.</p><p>What we have here is an Immediately Invoked Function Expression (IIFE). Basically, this block of code will be immediately executed when a user visits the webpage. Inside the IIFE, we have a variable called b, which contains a bunch of character codes. We then have a nested IIFE, which is wrapped around an <code>eval</code> call. The IIFE inside the eval is doing a very basic string decoder function. It’s looping through the characters in b, 2 at a time, and appending their ASCII equivalent values to the z variable.</p><h2 id="Decoding-the-script"><a href="#Decoding-the-script" class="headerlink" title="Decoding the script"></a>Decoding the script</h2><p>Now we have the code, we need to turn it into tangible Javascript code. Lets take the code from above and make a simpler decoder than will print out the decoded string to our console.</p><pre><code class="js">var b = &quot;766172205f3....&quot;var final = &quot;&quot;;for (var i = 0; i &lt; b.length; i += 2) &#123;  final += String.fromCharCode(parseInt(b.substring(i, i + 2), 16));&#125;console.log(final);</code></pre><p>So in our console we should now have the decoded string. It looks a bit scary at first, but if we run the output through a <a href="https://beautifier.io/">JS beautifier</a>, we get something that resembles somewhat recogniseable Javascript:</p><pre><code class="js">(function(_0x246fbc, _0x279367) &#123;    var _0x3ef8fa = function(_0x4e4813) &#123;        while (--_0x4e4813) &#123;            _0x246fbc[&#39;\x70\x75\x73\x68&#39;](_0x246fbc[&#39;\x73\x68\x69\x66\x74&#39;]());        &#125;    &#125;;    var _0x2247fc = function() &#123;        var _0x3108b4 = &#123;            &#39;\x64\x61\x74\x61&#39;: &#123;                &#39;\x6b\x65\x79&#39;: &#39;\x63\x6f\x6f\x6b\x69\x65&#39;,                &#39;\x76\x61\x6c\x75\x65&#39;: &#39;\x74\x69\x6d\x65\x6f\x75\x74&#39;            &#125;,            &#39;\x73\x65\x74\x43\x6f\x6f\x6b\x69\x65&#39;: function(_0x564ed7, _0x16e7cb, _0x1a47f2, _0x3f5a26) &#123;                _0x3f5a26 = _0x3f5a26 || &#123;&#125;;                var _0x7c508a = _0x16e7cb + &#39;\x3d&#39; + _0x1a47f2;                var _0x367e08 = 0x0;                for (var _0x367e08 = 0x0, _0x492c74 = _0x564ed7[&#39;\x6c\x65\x6e\x67\x74\x68&#39;]; _0x367e08 &lt; _0x492c74; _0x367e08++) &#123;                    var _0x2c0fa7 = _0x564ed7[_0x367e08];                    _0x7c508a += &#39;\x3b\x20&#39; + _0x2c0fa7;                    var _0x4478c3 = _0x564ed7[_0x2c0fa7];                    _0x564ed7[&#39;\x70\x75\x73\x68&#39;](_0x4478c3);                    _0x492c74 = _0x564ed7[&#39;\x6c\x65\x6e\x67\x74\x68&#39;];                    if (_0x4478c3 !== !![]) &#123;                        _0x7c508a += &#39;\x3d&#39; + _0x4478c3;                    &#125;                &#125;                _0x3f5a26[&#39;\x63\x6f\x6f\x6b\x69\x65&#39;] = _0x7c508a;            &#125;,            &#39;\x72\x65\x6d\x6f\x76\x65\x43\x6f\x6f\x6b\x69\x65&#39;: function() &#123;                return &#39;\x64\x65\x76&#39;;            &#125;,....</code></pre><p>Looking at the above, we can see that we have a few obfuscation techniques going on:</p><ul><li>Strings are protected by hexadecimal escape sequences (<code>\x</code> notation)</li><li>Variable names have been renamed to hexadecimal</li><li>Numbers have been replaced by their hexadecimal equivielent</li></ul><p>Just from experience, I know that these particular techniques are a result of <a href="https://obfuscator.io/">ObfuscatorIO</a>.</p><h2 id="Revealing-Strings"><a href="#Revealing-Strings" class="headerlink" title="Revealing Strings"></a>Revealing Strings</h2><p>As I mentioned previously, the strings are being represented by hexadecimal escape sequences, so we need to reveal and replaice them with their plaintext values. Luckily Babel provides a really easy way for us to do this. The plaintext value can be found in the <code>extra</code> property of the <code>StringLiteral</code> type:</p><p>And we can write a simple Babel visitor for this:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const ast = parser.parse(decoded);const revealStrings = &#123;  StringLiteral(path)&#123;    if (!path.node.extra) return;    path.replaceWith(t.stringLiteral(path.node.extra.rawValue))  &#125;&#125;traverse(ast, revealStrings);</code></pre><p>After we have run the above visitor, we’ve now reveleaed some of the strings, but we’re not fully done yet.</p><pre><code class="js"> var _0x2247fc = function () &#123;    var _0x3108b4 = &#123;      &quot;data&quot;: &#123;        &quot;key&quot;: &quot;cookie&quot;,        &quot;value&quot;: &quot;timeout&quot;      &#125;,      &quot;setCookie&quot;: function (_0x564ed7, _0x16e7cb, _0x1a47f2, _0x3f5a26) &#123;        _0x3f5a26 = _0x3f5a26 || &#123;&#125;;        var _0x7c508a = _0x16e7cb + &quot;=&quot; + _0x1a47f2;        var _0x367e08 = 0x0;        for (var _0x367e08 = 0x0, _0x492c74 = _0x564ed7[&quot;length&quot;]; _0x367e08 &lt; _0x492c74; _0x367e08++) &#123;          var _0x2c0fa7 = _0x564ed7[_0x367e08];          _0x7c508a += &quot;; &quot; + _0x2c0fa7;          var _0x4478c3 = _0x564ed7[_0x2c0fa7];          _0x564ed7[&quot;push&quot;](_0x4478c3);          _0x492c74 = _0x564ed7[&quot;length&quot;];          if (_0x4478c3 !== !![]) &#123;            _0x7c508a += &quot;=&quot; + _0x4478c3;</code></pre><p>So now we have all the strings in a readable format, but if we have a look in the script, we can still see that there are Base64 strings all over the place. Whilst some of the strings are now readable, there are still a lot of strings that aren’t. Throughout the script, there are repeated occurrences of this type of stuff: <code>_0xe3ea(&quot;0x44&quot;, &quot;@7QD&quot;)</code>, <code>_0xe3ea(&quot;0x4f&quot;, &quot;E@5e&quot;)</code> - a call expression with two parameters, a number represented as a hex string, and a string literal.</p><p>If we take a look at the function <code>_0xe3ea</code>, we can see references to “rc4”. RC4 is a symmetric stream cipher algorithm that is used for encrypting and decrypting strings. Again from experience, I know that RC4 string encryption is a feature of ObfuscatorIO. So based on this knowledge, can we assume that the <code>_0xe3ea</code> is an RC4 decoder function? Yes!</p><p>At the top of the script, we have a <code>VariableDeclaration</code>, which is initialized to an <code>ArrayExpression</code>. This again is a feature of ObfuscatorIO and is used to make reading strings harder. When you run code through ObfuscatorIO, it will take the strings, encrypt them using RC4, put them into an array and use a decoder function to find the correct string, decrypt it and return. We can write a visitor to store the values in an array:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;let wordArray = []const getWordArray = &#123;  Program(path)&#123;     wordArray = node.body[0].declarations[0].init.elements.map((val =&gt; val.value;));    path.stop();  &#125;&#125;traverse(ast, getWordArry);</code></pre><p>We now have an array of RC4 encrypted strings.</p><h2 id="Understanding-the-RC4-String-Encryption"><a href="#Understanding-the-RC4-String-Encryption" class="headerlink" title="Understanding the RC4 String Encryption"></a>Understanding the RC4 String Encryption</h2><h3 id="Word-Array-and-Shuffle"><a href="#Word-Array-and-Shuffle" class="headerlink" title="Word Array and Shuffle"></a>Word Array and Shuffle</h3><p>Before we get too far into the the RC4  encryption, we need to understand how the RC4 encrypted strings are stored in the script. Just above the RC4 decryption function, we have another IIFE:</p><pre><code class="js">(function (_0x246fbc, _0x279367) &#123;  var _0x3ef8fa = function (_0x4e4813) &#123;    while (--_0x4e4813) &#123;      _0x246fbc[&quot;push&quot;](_0x246fbc[&quot;shift&quot;]());    &#125;  &#125;;  var _0x2247fc = function () &#123;    var _0x3108b4 = &#123;      &quot;data&quot;: &#123;        &quot;key&quot;: &quot;cookie&quot;,        &quot;value&quot;: &quot;timeout&quot;      &#125;,      &quot;setCookie&quot;: function (_0x564ed7, _0x16e7cb, _0x1a47f2, _0x3f5a26) &#123;        _0x3f5a26 = _0x3f5a26 || &#123;&#125;;        var _0x7c508a = _0x16e7cb + &quot;=&quot; + _0x1a47f2;        var _0x367e08 = 0x0;        for (var _0x367e08 = 0x0, _0x492c74 = _0x564ed7[&quot;length&quot;]; _0x367e08 &lt; _0x492c74; _0x367e08++) &#123;          var _0x2c0fa7 = _0x564ed7[_0x367e08];          _0x7c508a += &quot;; &quot; + _0x2c0fa7;          var _0x4478c3 = _0x564ed7[_0x2c0fa7];          _0x564ed7[&quot;push&quot;](_0x4478c3);          _0x492c74 = _0x564ed7[&quot;length&quot;];          if (_0x4478c3 !== !![]) &#123;            _0x7c508a += &quot;=&quot; + _0x4478c3;          &#125;        &#125;        _0x3f5a26[&quot;cookie&quot;] = _0x7c508a;      &#125;,      &quot;removeCookie&quot;: function () &#123;        return &quot;dev&quot;;      &#125;,      &quot;getCookie&quot;: function (_0x230827, _0x3e3448) &#123;        _0x230827 = _0x230827 || function (_0x3772b8) &#123;          return _0x3772b8;        &#125;;        var _0x26af38 = _0x230827(new RegExp(&quot;(?:^|; )&quot; + _0x3e3448[&quot;replace&quot;](/([.$?*|&#123;&#125;()[]\/+^])/g, &quot;$1&quot;) + &quot;=([^;]*)&quot;));        var _0x4fd28d = function (_0x53e56d, _0xd00715) &#123;          _0x53e56d(++_0xd00715);        &#125;;        _0x4fd28d(_0x3ef8fa, _0x279367);        return _0x26af38 ? decodeURIComponent(_0x26af38[0x1]) : undefined;      &#125;    &#125;;    var _0x255171 = function () &#123;      var _0x5b8adf = new RegExp(&quot;\\w+ *\\(\\) *&#123;\\w+ *[&#39;|\&quot;].+[&#39;|\&quot;];? *&#125;&quot;);      return _0x5b8adf[&quot;test&quot;](_0x3108b4[&quot;removeCookie&quot;][&quot;toString&quot;]());    &#125;;    _0x3108b4[&quot;updateCookie&quot;] = _0x255171;    var _0xecc8a7 = &quot;&quot;;    var _0x586381 = _0x3108b4[&quot;updateCookie&quot;]();    if (!_0x586381) &#123;      _0x3108b4[&quot;setCookie&quot;]([&quot;*&quot;], &quot;counter&quot;, 0x1);    &#125; else if (_0x586381) &#123;      _0xecc8a7 = _0x3108b4[&quot;getCookie&quot;](null, &quot;counter&quot;);    &#125; else &#123;      _0x3108b4[&quot;removeCookie&quot;]();    &#125;  &#125;;  _0x2247fc();&#125;)(_0x3eae, 0x14a);</code></pre><p>This time the IFFE has two parameters: <code>_0x3eae</code> and <code>0x14a</code>. <code>_0x3eae</code> is the word array that we extracted above (an <code>ArrayExpression</code> of encrypted strings) and <code>0x14a</code> is a literal that has a numeric value of <code>330</code>. This number is important. The array of strings is out of order and this number is the ‘magic number’ which is used to shuffle the array to get them back in the correct order.</p><p>This is the shuffle code from the script:</p><pre><code class="js">var _0x3ef8fa = function (_0x4e4813) &#123;  while (--_0x4e4813) &#123;    _0x246fbc[&quot;push&quot;](_0x246fbc[&quot;shift&quot;]());  &#125;&#125;;</code></pre><p>But it can be re-written to something a bit easier to read:</p><pre><code class="js">function shuffleWordArray(array, num) &#123;  while (--num) &#123;    array.push(array.shift());  &#125;&#125;</code></pre><p>We now need to shuffle our encrypted string array by the magic number to ensure that the strings are in the correct order in the array:</p><pre><code class="js">//shuffle the array to ensure it&#39;s in the correct ordershuffleWordArray(wordArray, magicNumber);//wordArray is now in the correct order</code></pre><h3 id="RC4-Deep-Dive"><a href="#RC4-Deep-Dive" class="headerlink" title="RC4 Deep Dive"></a>RC4 Deep Dive</h3><p>This is the entire RC4 decoder function, I’ve added some comments to make it easier to understand:</p><pre><code class="js">var _0xe3ea = function (_0x246fbc, _0x279367) &#123;  _0x246fbc = _0x246fbc - 0x0;  //_0x3eae - This is our huge word array at the top of the script which contains all the RC4 encrypted strings  //_0x246fbc - This is an index getter for the array  var _0x3ef8fa = _0x3eae[_0x246fbc];    if (_0xe3ea[&quot;initialized&quot;] === undefined) &#123;    //A Base64 Encoder/Decoder    (function () &#123;      var _0x45df7b = Function(&quot;return (function () &quot; + &quot;&#123;&#125;.constructor(\&quot;return this\&quot;)()&quot; + &quot;);&quot;);      var _0x2247fc = _0x45df7b();      var _0x3108b4 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;      _0x2247fc[&quot;atob&quot;] || (_0x2247fc[&quot;atob&quot;] = function (_0x564ed7) &#123;        var _0x16e7cb = String(_0x564ed7)[&quot;replace&quot;](/=+$/, &quot;&quot;);        for (var _0x1a47f2 = 0x0, _0x3f5a26, _0x7c508a, _0x76115b = 0x0, _0x367e08 = &quot;&quot;; _0x7c508a = _0x16e7cb[&quot;charAt&quot;](_0x76115b++); ~_0x7c508a &amp;&amp; (_0x3f5a26 = _0x1a47f2 % 0x4 ? _0x3f5a26 * 0x40 + _0x7c508a : _0x7c508a, _0x1a47f2++ % 0x4) ? _0x367e08 += String[&quot;fromCharCode&quot;](0xff &amp; _0x3f5a26 &gt;&gt; (-0x2 * _0x1a47f2 &amp; 0x6)) : 0x0) &#123;          _0x7c508a = _0x3108b4[&quot;indexOf&quot;](_0x7c508a);        &#125;        return _0x367e08;      &#125;);    &#125;)();        //The actual RC4 encryption code, parameter 1 is the encrypted string, parameter 2 is the key    var _0x492c74 = function (_0x2c0fa7, _0x4478c3) &#123;      var _0x230827 = [],        _0x3e3448 = 0x0,        _0x3772b8,        _0x26af38 = &quot;&quot;,        _0x4fd28d = &quot;&quot;;      _0x2c0fa7 = atob(_0x2c0fa7);      for (var _0x53e56d = 0x0, _0xd00715 = _0x2c0fa7[&quot;length&quot;]; _0x53e56d &lt; _0xd00715; _0x53e56d++) &#123;        _0x4fd28d += &quot;%&quot; + (&quot;00&quot; + _0x2c0fa7[&quot;charCodeAt&quot;](_0x53e56d)[&quot;toString&quot;](0x10))[&quot;slice&quot;](-0x2);      &#125;      _0x2c0fa7 = decodeURIComponent(_0x4fd28d);      for (var _0x255171 = 0x0; _0x255171 &lt; 0x100; _0x255171++) &#123;        _0x230827[_0x255171] = _0x255171;      &#125;      for (_0x255171 = 0x0; _0x255171 &lt; 0x100; _0x255171++) &#123;        _0x3e3448 = (_0x3e3448 + _0x230827[_0x255171] + _0x4478c3[&quot;charCodeAt&quot;](_0x255171 % _0x4478c3[&quot;length&quot;])) % 0x100;        _0x3772b8 = _0x230827[_0x255171];        _0x230827[_0x255171] = _0x230827[_0x3e3448];        _0x230827[_0x3e3448] = _0x3772b8;      &#125;      _0x255171 = 0x0;      _0x3e3448 = 0x0;      for (var _0x5b8adf = 0x0; _0x5b8adf &lt; _0x2c0fa7[&quot;length&quot;]; _0x5b8adf++) &#123;        _0x255171 = (_0x255171 + 0x1) % 0x100;        _0x3e3448 = (_0x3e3448 + _0x230827[_0x255171]) % 0x100;        _0x3772b8 = _0x230827[_0x255171];        _0x230827[_0x255171] = _0x230827[_0x3e3448];        _0x230827[_0x3e3448] = _0x3772b8;        _0x26af38 += String[&quot;fromCharCode&quot;](_0x2c0fa7[&quot;charCodeAt&quot;](_0x5b8adf) ^ _0x230827[(_0x230827[_0x255171] + _0x230827[_0x3e3448]) % 0x100]);      &#125;      return _0x26af38;    &#125;;    _0xe3ea[&quot;rc4&quot;] = _0x492c74;    _0xe3ea[&quot;data&quot;] = &#123;&#125;;    _0xe3ea[&quot;initialized&quot;] = !![];  &#125;  var _0xecc8a7 = _0xe3ea[&quot;data&quot;][_0x246fbc];  if (_0xecc8a7 === undefined) &#123;    if (_0xe3ea[&quot;once&quot;] === undefined) &#123;      var _0x586381 = function (_0x3328ca) &#123;        this[&quot;rc4Bytes&quot;] = _0x3328ca;        this[&quot;states&quot;] = [0x1, 0x0, 0x0];        this[&quot;newState&quot;] = function () &#123;          return &quot;newState&quot;;        &#125;;        this[&quot;firstState&quot;] = &quot;\\w+ *\\(\\) *&#123;\\w+ *&quot;;        this[&quot;secondState&quot;] = &quot;[&#39;|\&quot;].+[&#39;|\&quot;];? *&#125;&quot;;      &#125;;      _0x586381[&quot;prototype&quot;][&quot;checkState&quot;] = function () &#123;        var _0x17ea7d = new RegExp(this[&quot;firstState&quot;] + this[&quot;secondState&quot;]);        return this[&quot;runState&quot;](_0x17ea7d[&quot;test&quot;](this[&quot;newState&quot;][&quot;toString&quot;]()) ? --this[&quot;states&quot;][0x1] : --this[&quot;states&quot;][0x0]);      &#125;;      _0x586381[&quot;prototype&quot;][&quot;runState&quot;] = function (_0x4355f3) &#123;        if (!Boolean(~_0x4355f3)) &#123;          return _0x4355f3;        &#125;        return this[&quot;getState&quot;](this[&quot;rc4Bytes&quot;]);      &#125;;      _0x586381[&quot;prototype&quot;][&quot;getState&quot;] = function (_0x27ff93) &#123;        for (var _0x55a624 = 0x0, _0xa7b380 = this[&quot;states&quot;][&quot;length&quot;]; _0x55a624 &lt; _0xa7b380; _0x55a624++) &#123;          this[&quot;states&quot;][&quot;push&quot;](Math[&quot;round&quot;](Math[&quot;random&quot;]()));          _0xa7b380 = this[&quot;states&quot;][&quot;length&quot;];        &#125;        return _0x27ff93(this[&quot;states&quot;][0x0]);      &#125;;      new _0x586381(_0xe3ea)[&quot;checkState&quot;]();      _0xe3ea[&quot;once&quot;] = !![];    &#125;    _0x3ef8fa = _0xe3ea[&quot;rc4&quot;](_0x3ef8fa, _0x279367);    _0xe3ea[&quot;data&quot;][_0x246fbc] = _0x3ef8fa;  &#125; else &#123;    _0x3ef8fa = _0xecc8a7;  &#125;  return _0x3ef8fa;&#125;;</code></pre><p>Inside the RC4 code, we can see this: <code>_0xe3ea[&quot;rc4&quot;] = _0x492c74;</code>. What this tells us is that the the actual RC4 decryption function is defined in <code>_0x492c74</code>. If we have a look at <code>_0x492c74</code> we can see that it takes two parameters; lets assume the first parameter is the encrypted string and the second parameter is the decryption key.  Next we can isolate the RC4 function and pull it out so we can use it as a a standalone piece of code later. Again we can write a simple Babel plugin to extract the function:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;let rc4Function;const findRc4Function = &#123;  AssignmentExpression(path)&#123;     const &#123; node &#125; = path;        // Find the &#39;_0xe3ea[&quot;rc4&quot;] = _0x492c74;&#39; node    if (t.isMemberExpression(node.left) &amp;&amp;       node.left.property.value === &quot;rc4&quot;     ) &#123;      // Go back 1 node and get the RC4 function      rc4Function = path.getStatementParent().getPrevSibling();      path.stop();    &#125;  &#125;&#125;traverse(ast, findRc4Function);</code></pre><p>You can see what the code looks like by using the <code>generate</code> function:</p><pre><code class="js">const generatedCode = generate(rc4Function.node).codeconsole.log(generatedCode);// OUTPUT BELOWvar _0x2e9201 = function (_0x22a61c, _0x3e557b) &#123;  var _0x4eaa1b = [],    _0xa3379e = 0x0,    _0x48c4b8,    _0x27e820 = &quot;&quot;,    _0x2afcf0 = &quot;&quot;;  _0x22a61c = atob(_0x22a61c);  for (var _0x3f2921 = 0x0, _0x358e09 = _0x22a61c[&quot;length&quot;]; _0x3f2921 &lt; _0x358e09; _0x3f2921++) &#123;    _0x2afcf0 += &quot;%&quot; + (&quot;00&quot; + _0x22a61c[&quot;charCodeAt&quot;](_0x3f2921)[&quot;toString&quot;](0x10))[&quot;slice&quot;](-0x2);  &#125;  _0x22a61c = decodeURIComponent(_0x2afcf0);  for (var _0x5d8355 = 0x0; _0x5d8355 &lt; 0x100; _0x5d8355++) &#123;    _0x4eaa1b[_0x5d8355] = _0x5d8355;  &#125;  for (_0x5d8355 = 0x0; _0x5d8355 &lt; 0x100; _0x5d8355++) &#123;    _0xa3379e = (_0xa3379e + _0x4eaa1b[_0x5d8355] + _0x3e557b[&quot;charCodeAt&quot;](_0x5d8355 % _0x3e557b[&quot;length&quot;])) % 0x100;    _0x48c4b8 = _0x4eaa1b[_0x5d8355];    _0x4eaa1b[_0x5d8355] = _0x4eaa1b[_0xa3379e];    _0x4eaa1b[_0xa3379e] = _0x48c4b8;  &#125;  _0x5d8355 = 0x0;  _0xa3379e = 0x0;  for (var _0x40cbb7 = 0x0; _0x40cbb7 &lt; _0x22a61c[&quot;length&quot;]; _0x40cbb7++) &#123;    _0x5d8355 = (_0x5d8355 + 0x1) % 0x100;    _0xa3379e = (_0xa3379e + _0x4eaa1b[_0x5d8355]) % 0x100;    _0x48c4b8 = _0x4eaa1b[_0x5d8355];    _0x4eaa1b[_0x5d8355] = _0x4eaa1b[_0xa3379e];    _0x4eaa1b[_0xa3379e] = _0x48c4b8;    _0x27e820 += String[&quot;fromCharCode&quot;](_0x22a61c[&quot;charCodeAt&quot;](_0x40cbb7) ^ _0x4eaa1b[(_0x4eaa1b[_0x5d8355] + _0x4eaa1b[_0xa3379e]) % 0x100]);  &#125;  return _0x27e820;&#125;;</code></pre><p>We now have the RC4 decryption function isolated by itself. We don’t need to deobfuscate this any further as we don’t really care about the internals of this function, only what it produces. If you re-call from earlier, I said that we saw this type of code all over the place: <code>_0xe3ea(&quot;0x44&quot;, &quot;@7QD&quot;)</code>. We’ve now discovered that the RC4 decryption function is nested inside <code>_0xe3ea</code>, and <code>_0xe3ea</code> is a “getter” that internally calls the RC4 function and spits out the decrypted value. At the top of the getter we can see a reference with an index to our word array (<code>_0x3eae</code>). What this code is doing is fetching the encrypted string from our array, and then sending it to the RC4 decrypter. This is why it was important for us to shuffle the array before we got to this stage, otherwise we’d get the wrong decrypted string back!</p><pre><code class="js">var _0xe3ea = function (_0x246fbc, _0x279367) &#123;  _0x246fbc = _0x246fbc - 0x0;  var _0x3ef8fa = _0x3eae[_0x246fbc]; // &lt;&lt; This is a reference to the word arary with an index</code></pre><h3 id="Putting-it-together"><a href="#Putting-it-together" class="headerlink" title="Putting it together"></a>Putting it together</h3><p>We now have all the information we need to create our next Babel visitor, which will be used to replace the encrypted strings. We have the following knowledge:</p><ul><li>An array of encrypted strings (shuffled to be in the correct order)</li><li>A reference to the RC4 function</li><li>The identifier name of the <code>VariableDeclarator</code> which contains the array of strings</li><li>The “getter” fuction identifier which calls the RC4 function internally</li></ul><p>We can use <code>vm</code> to create a small context spearate from our main code, which will execute and return a value. We’re going to setup a context which contains just the RC4 code, call it from our visitor, and do a replacement:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const generate = require(&quot;@babel/generator&quot;).default;const vm = require(&quot;vm&quot;);function atob(a) &#123;    return new Buffer(a, &#39;base64&#39;).toString(&#39;binary&#39;);&#125;;const revealStringsVisitor = &#123;    AssignmentExpression(path)&#123;      const &#123; node &#125; = path;      if (          t.isMemberExpression(node.left) &amp;&amp;          node.left.property.value === &quot;rc4&quot;      )&#123;          // This is a variable to a function, i.e.  var _0x1cb434 = function (_0xc7576, _0x14cfd3) &#123; .. rc4 stuff          const rc4FuncVariableDeclaration = path.getStatementParent().getPrevSibling();                    // This is a &quot;getter&quot; that calls the RC4 function, i.e. the outer function          const getterFunction = rc4FuncVariableDeclaration.getFunctionParent().getStatementParent()          // The word array identifier          // var _0x3ef8fa = _0x3eae[_0x246fbc];          const arrayName = getterFunction.get(&quot;declarations.0.init.body&quot;).node.body[1].declarations[0].init.object.name;          const decoderFuncName = getterFunction.node.declarations[0].id.name;          //Setup a context with atob          const ctx = &#123;atob: atob&#125;          vm.runInNewContext(generate(rc4FuncVariableDeclaration.node).code, ctx);          const binding = path.scope.getBinding(decoderFuncName);          // Find all references to the decoder, i.e. _0xe3ea(&quot;0x44&quot;, &quot;@7QD&quot;)          for(const ref of binding.referencePaths)&#123;              if (                  t.isIdentifier(ref.parentPath.node.callee) &amp;&amp;                  t.isCallExpression(ref.parentPath) &amp;&amp;                  ref.parentPath.node.arguments.length === 2 &amp;&amp;                  ref.parentPath.node.arguments[0].type === &quot;StringLiteral&quot; &amp;&amp;                  ref.parentPath.node.arguments[1].type === &quot;StringLiteral&quot;              ) &#123;                  // Index is the first parameter, and lets conver to an int                  const index = parseInt(ref.parentPath.node.arguments[0].value);                  // Key is the 2nd parameter                  const key = ref.parentPath.node.arguments[1].value;                  // Call the RC4 decryption function inside the context, and get the output                  // Remember we already shuffled the wordArray earlier, so it is in the correct order now!                  const decryptedValue = ctx[rc4FuncVariableDeclaration.node.declarations[0].id.name](wordArray[index], key)                  // Do a plain text replacement                  ref.parentPath.replaceWith(t.valueToNode(decryptedValue));              &#125;          &#125;      &#125;  &#125; &#125;</code></pre><p>After running this plugin, we now have all strings revelaed!</p><pre><code class="js">...  var _0x19a5d8 = this[&quot;window&quot;];var _0x145c56 = _0x19a5d8[&quot;document&quot;];var _0xc68334 = &quot;&quot;;var _0x641c3c = &quot;&quot;;if (_0x2f96a5[&quot;yEQ&quot;](typeof _0x19a5d8[&quot;console&quot;], &quot;undefined&quot;)) &#123;  _0xc68334 = _0x19a5d8[&quot;console&quot;];  _0x641c3c = _0xc68334[&quot;log&quot;];&#125;var _0x2b232b = _0x19a5d8[&quot;navigator&quot;];var _0x35da0a = _0x19a5d8[&quot;encodeURIComponent&quot;];var _0x3ed2cd = new _0x19a5d8[&quot;Date&quot;]()[&quot;getTime&quot;]();...</code></pre><p>That’s it for part 1, and just to re-cap we have now successfully:</p><ul><li>Understood how to decode the intial script into something more readable</li><li>Removed the <code>\x</code> string notation</li><li>Replaced all strings with their unencrypted plain-text values</li></ul><p>In the next part, we’ll have a look at flattening the control flow of the script</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Deobfuscating Imperva&#39;s utmvc Anti-Bot Script - Part 2</title>
      <link href="/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot-Part-2/"/>
      <url>/2023/03/04/Deobfuscating-Incapsula-s-UTMVC-Anti-Bot-Part-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Part-2-Control-Flow-Flattening"><a href="#Part-2-Control-Flow-Flattening" class="headerlink" title="Part 2 - Control Flow Flattening"></a><strong>Part 2 - Control Flow Flattening</strong></h1><h2 id="Flattening-Control-Flow"><a href="#Flattening-Control-Flow" class="headerlink" title="Flattening Control Flow"></a>Flattening Control Flow</h2><p>In part 1 we successfully revealed all of the strings in the script. In this part, we are going to tackle the control flow obfuscation. Control flow obfuscation is a technique to jumble up the order of code in order to make it harder to follow. It jumps around and is usually found in a <code>switch</code> block. I’ve included a visual representation of what that might look like below.</p><p><img src="https://pbs.twimg.com/media/FSEiVswXIAIqe7n.jpg" alt="Virus Bulletin on Twitter: &quot;Sophos&#39; @hackingump1 writes an introduction to control  flow flattening in Emotet. Control flow flattening is an obfuscation  technique that hides program flow by putting all function blocks next"></p><p>We can see examples of this in the script we’ve partially deobfuscated so far:</p><pre><code class="js">    var _0x3100a2 = &quot;4|2|3|1|6|5|7|0|9|8&quot;[&quot;split&quot;](&quot;|&quot;),      _0x6753ae = 0x0;    while (!![]) &#123;      switch (_0x3100a2[_0x6753ae++]) &#123;        case &quot;0&quot;:          _0x4e96ba[&quot;Pgl&quot;](_0x14d4e9, _0x4e96ba[&quot;uLq&quot;](_0x2bcd36, _0x4bc649));          continue;        case &quot;1&quot;:          _0x4bc649[&quot;push&quot;]([&quot;&#39;v8b33affa616d7e2343cc7cd58fb6cd20c99ad6b16413b7c5af014cfde3a957ad&#39;.toString()&quot;, &quot;value&quot;]);          continue;        case &quot;2&quot;:          if (!_0x530384[&quot;btoa&quot;]) _0x530384[&quot;btoa&quot;] = _0x48c673;          continue;        case &quot;3&quot;:          _0x4e96ba[&quot;gGv&quot;](_0x3abf6a);          continue;        case &quot;4&quot;:          if (_0x1e92fd) &#123;            try &#123;              _0x2e9a92[&quot;log&quot;] = _0x4e96ba[&quot;uLq&quot;](_0x19195e, _0x1e92fd);            &#125; catch (_0x3fc75d) &#123;&#125;          &#125;          continue;        case &quot;5&quot;:          var _0x290d1c = _0x20a23a[&quot;substr&quot;](0x0, 0x2);          continue;        case &quot;6&quot;:          var _0x20a23a = &quot;bO+/vQxkbu+/vXQgXu+/ve+/vUHvv73vv71d77+9&quot;;          continue;        case &quot;7&quot;:          var _0x5a434c = _0x20a23a[&quot;substr&quot;](0x2);          continue;        case &quot;8&quot;:          _0x4fd281[&quot;createElement&quot;](&quot;img&quot;)[&quot;src&quot;] = _0x4e96ba[&quot;LZO&quot;](&quot;/_Incapsula_Resource?SWKMTFSR=1&amp;e=&quot;, _0x530384[&quot;Math&quot;][&quot;random&quot;]());          continue;        case &quot;9&quot;:          if (_0x163515) &#123;            _0x4bc649[&quot;push&quot;]([_0x163515, &quot;value&quot;]);            _0x4e96ba[&quot;uLq&quot;](_0x14d4e9, _0x4e96ba[&quot;FRS&quot;](_0x2bcd36, _0x4bc649));          &#125;          continue;      &#125;      break;    &#125;</code></pre><p>We can see that <code>_0x3100a2</code> is a variable which contains string literals, that is <code>split</code> by <code>|</code>. The <code>swtich</code> statement then loops through each element and runs the code under each switch statement. The end goal here is to simplify the code to something like this:</p><pre><code class="js">//Code from switch &quot;4&quot;if (_0x1e92fd) &#123;try &#123;  _0x2e9a92[&quot;log&quot;] = _0x4e96ba[&quot;uLq&quot;](_0x19195e, _0x1e92fd);&#125; catch (_0x3fc75d) &#123;&#125;&#125;//Code from switch &quot;2&quot;if (!_0x530384[&quot;btoa&quot;]) _0x530384[&quot;btoa&quot;] = _0x48c673;//Code from switch &quot;3&quot;_0x4e96ba[&quot;gGv&quot;](_0x3abf6a);//Code from switch &quot;1&quot;_0x4bc649[&quot;push&quot;]([&quot;&#39;v8b33affa616d7e2343cc7cd58fb6cd20c99ad6b16413b7c5af014cfde3a957ad&#39;.toString()&quot;, &quot;value&quot;]);... etc</code></pre><p>And here is our resulting Babel plugin:</p><pre><code class="js">const t = require(&quot;@babel/types&quot;);const parser = require(&quot;@babel/parser&quot;);const traverse = require(&quot;@babel/traverse&quot;).default;const flattenControlFlowVisitor = &#123;    SwitchStatement(path)&#123;        const &#123; node &#125; = path;        if(t.isMemberExpression(node.discriminant) &amp;&amp;            t.isIdentifier(node.discriminant.object) &amp;&amp;            t.isUpdateExpression(node.discriminant.property) &amp;&amp;            node.discriminant.property.operator === &quot;++&quot; &amp;&amp;            node.discriminant.property.prefix === false)        &#123;            //We&#39;re in the right switch statement            //Get the switch order variable name            //e.g.     var _0x48d663 = &quot;3|6|2|0|5|1|4&quot;[&quot;split&quot;](&quot;|&quot;), ---&gt; _0x48d663            const switchOrderVar = node.discriminant.object.name;            //Get the bindings of the variable and get the switch order into an array            const switchOrder = path.scope.getBinding(switchOrderVar).path.node.init.callee.object.value.split(&quot;|&quot;)            let orderedNodes = []            //Loop through the switch order            for(const sw of switchOrder)&#123;                //Get the switch cases that belong to the switch                const switchCase = path.node.cases.find(c =&gt; c.test.value === sw);                                //Get the nodes under the switch excluding the continue statement                const nodesInSwitchCase = switchCase.consequent.filter(c =&gt; !t.isContinueStatement(c))                                //Drop them into an array                //cloneDeepWithoutLoc to avoid issues!                orderedNodes.push(...nodesInSwitchCase.map(n =&gt; t.cloneDeepWithoutLoc(n)))            &#125;                        //Replace the parent while statement            const whileStatement = path.parentPath.parentPath;            whileStatement.replaceWithMultiple(orderedNodes);        &#125;    &#125;&#125;traverse(ast, flattenControlFlowVisitor);traverse(ast, flattenControlFlowVisitor); //Run it twice!</code></pre><p>You’ll notice that we need to run this visitor twice, this is because there are nested switch statements. One improvement that could be made to this visitor is to make it recursive. This would make it more efficient and mean that we don’t have to traverse the AST twice. We’ve now simplified the ugly control flow code into this:</p><pre><code class="js">function _0x4d748b(_0x1b013d) &#123;var _0x3a900f = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;var _0x2026be, _0x30a9be, _0x105a8e;var _0x337f59, _0x32ce20, _0x52c47a;_0x105a8e = _0x1b013d[&quot;length&quot;];_0x30a9be = 0x0;_0x2026be = &quot;&quot;;while (_0x388c13[&quot;wag&quot;](_0x30a9be, _0x105a8e)) &#123;  var _0x4a9695 = &quot;6|8|7|2|0|1|4|3|5&quot;[&quot;split&quot;](&quot;|&quot;),    _0x1a9326 = 0x0;  _0x337f59 = _0x388c13[&quot;YnZ&quot;](_0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++), 0xff);  if (_0x388c13[&quot;PNJ&quot;](_0x30a9be, _0x105a8e)) &#123;    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x337f59 &gt;&gt; 0x2);    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;fza&quot;](_0x388c13[&quot;yuG&quot;](_0x337f59, 0x3), 0x4));    _0x2026be += &quot;==&quot;;    break;  &#125;  _0x32ce20 = _0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++);  if (_0x388c13[&quot;PNJ&quot;](_0x30a9be, _0x105a8e)) &#123;    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;ydV&quot;](_0x337f59, 0x2));    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;AfV&quot;](_0x388c13[&quot;XCm&quot;](_0x337f59, 0x3) &lt;&lt; 0x4, (_0x32ce20 &amp; 0xf0) &gt;&gt; 0x4));    _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;pYD&quot;](_0x32ce20, 0xf) &lt;&lt; 0x2);    _0x2026be += &quot;=&quot;;    break;  &#125;  _0x52c47a = _0x1b013d[&quot;charCodeAt&quot;](_0x30a9be++);  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;Oed&quot;](_0x337f59, 0x2));  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;VuS&quot;](_0x388c13[&quot;jpt&quot;](_0x337f59, 0x3) &lt;&lt; 0x4, _0x388c13[&quot;ydV&quot;](_0x388c13[&quot;EML&quot;](_0x32ce20, 0xf0), 0x4)));  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;sWH&quot;](_0x32ce20 &amp; 0xf, 0x2) | _0x388c13[&quot;ydV&quot;](_0x388c13[&quot;uQC&quot;](_0x52c47a, 0xc0), 0x6));  _0x2026be += _0x3a900f[&quot;charAt&quot;](_0x388c13[&quot;EML&quot;](_0x52c47a, 0x3f));&#125;return _0x2026be;&#125;</code></pre><h2 id="Removing-Proxy-References"><a href="#Removing-Proxy-References" class="headerlink" title="Removing Proxy References"></a>Removing Proxy References</h2><p>The next obfuscation technique we’re going to tackle is proxy references. Proxy references are calls to functions that execute another function. The end goal here is to replace any calls to proxy functions with their intended function calls.</p><p>We can see examples of proxy calls in the code, e.g:</p><pre><code class="js">&quot;Pjt&quot;: function _0x1068f3(_0x1dcc0d, _0x4fccf2) &#123;  return _0x1dcc0d + _0x4fccf2;&#125;,</code></pre><p>Here we have a function that is defined as <code>Pjt</code>, and all this is doing is doing a simple addition on the two parameters.</p><p>First thing we need to do is traverse through the script and identify any objects that define the proxy functions. You’ll see that the proxy references are contained in an object like so:</p><pre><code class="js">var _0x388c13 = &#123;&quot;wag&quot;: function _0x67d457(_0x2f20be, _0x4a591a) &#123;  return _0x2f20be &lt; _0x4a591a;&#125;,</code></pre><p>The goal is to build a lookup table of the object variable name (<code>_0x388c13</code>) and all the proxy functions it contains. We can achieve this with this visitor:</p><pre><code class="js">this.proxyFuncVars = &#123;&#125;path.traverse(&#123;    ObjectProperty(path)&#123;        const &#123; node &#125; = path;        if (t.isFunctionExpression(node.value) &amp;&amp; t.isReturnStatement(node.value.body.body[0]))&#123;            //Found a proxy expression            const varDecl = path.getStatementParent()            if (!this.proxyFuncVars[varDecl.node.declarations[0].id.name]) &#123;                this.proxyFuncVars[varDecl.node.declarations[0].id.name] = [];            &#125;            this.proxyFuncVars[varDecl.node.declarations[0].id.name].push([node.key.value, node.value]);        &#125;    &#125;&#125;)</code></pre><p>We now have a lookup table that looks like this:</p><p><img src="/images/2.png" alt="image-20230306151919010"></p><p>The next thing that we need to do is traverse <code>CallExpressions</code> and see if it belongs in our lookup table. If it does, we can simply replace the <code>CallExpression</code> with the proxy function. Here is a visitor that does just that:</p><pre><code class="js">function findProxyFunction(lookupTable, varName, funcName)&#123;    for(const key of Object.keys(lookupTable))&#123;        if (key === varName)&#123;            for(const func of lookupTable[key])&#123;                if (func[0] === funcName)&#123;                    return func[1]                &#125;            &#125;        &#125;    &#125;    return null&#125;CallExpression(path)&#123;    const &#123; node &#125; = path;    if (        t.isMemberExpression(node.callee) &amp;&amp;        t.isIdentifier(node.callee.object) &amp;&amp;        findProxyFunction(this.proxyFuncVars, node.callee.object.name, node.callee.property.name)    )&#123;        const varName = node.callee.object.name;        const funcName =  node.callee.property.name;        const proxyFunc = findProxyFunction(this.proxyFuncVars, varName, funcName);        if (proxyFunc)&#123;            //We found a proxy function, so do a replacement            if (t.isBinaryExpression(proxyFunc.body.body[0].argument))&#123;                const funcBinaryExpression = proxyFunc.body.body[0].argument;                path.replaceWith(t.binaryExpression(funcBinaryExpression.operator, node.arguments[0], node.arguments[1]))            &#125; else if (t.isCallExpression(proxyFunc.body.body[0].argument))&#123;                const funcName = node.arguments.slice(1);                path.replaceWith(t.callExpression(node.arguments[0], funcName))            &#125;        &#125;    &#125;&#125;,</code></pre><blockquote><p><strong>Caution:</strong> The above code doesn’t consider the ordering of the arguments. For the utmvc script it’s not a problem since they’re always in order, however you should consider the argument positioning for other obfuscated code</p></blockquote><p>We’ve now transformed the code and removed all the proxy references!</p><p>Before:</p><pre><code class="js">_0x25c494[_0x25c494.length] = _0x5cf4da.bfY(_0x4ce1f7, _0x5cf4da.szJ(_0x412285, &quot;=undefined&quot;));</code></pre><p>After:</p><pre><code class="js">_0x25c494[_0x25c494.length] = _0x4ce1f7(_0x412285 + &quot;=undefined&quot;);</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
